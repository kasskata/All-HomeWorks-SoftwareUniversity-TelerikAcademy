(function (a) { a.fn.zclip = function (c) { if (typeof c == "object" && !c.length) { var b = a.extend({ path: "ZeroClipboard.swf", copy: null, beforeCopy: null, afterCopy: null, clickAfter: true, setHandCursor: true, setCSSEffects: true }, c); return this.each(function () { var e = a(this); if (e.is(":visible") && (typeof b.copy == "string" || a.isFunction(b.copy))) { ZeroClipboard.setMoviePath(b.path); var d = new ZeroClipboard.Client(); if (a.isFunction(b.copy)) { e.bind("zClip_copy", b.copy) } if (a.isFunction(b.beforeCopy)) { e.bind("zClip_beforeCopy", b.beforeCopy) } if (a.isFunction(b.afterCopy)) { e.bind("zClip_afterCopy", b.afterCopy) } d.setHandCursor(b.setHandCursor); d.setCSSEffects(b.setCSSEffects); d.addEventListener("mouseOver", function (f) { e.trigger("mouseenter") }); d.addEventListener("mouseOut", function (f) { e.trigger("mouseleave") }); d.addEventListener("mouseDown", function (f) { e.trigger("mousedown"); if (!a.isFunction(b.copy)) { d.setText(b.copy) } else { d.setText(e.triggerHandler("zClip_copy")) } if (a.isFunction(b.beforeCopy)) { e.trigger("zClip_beforeCopy") } }); d.addEventListener("complete", function (f, g) { if (a.isFunction(b.afterCopy)) { e.trigger("zClip_afterCopy") } else { if (g.length > 500) { g = g.substr(0, 500) + "...\n\n(" + (g.length - 500) + " characters not shown)" } e.removeClass("hover"); } if (b.clickAfter) { e.trigger("click") } }); d.glue(e[0], e.parent()[0]); a(window).bind("load resize", function () { d.reposition() }) } }) } else { if (typeof c == "string") { return this.each(function () { var f = a(this); c = c.toLowerCase(); var e = f.data("zclipId"); var d = a("#" + e + ".zclip"); if (c == "remove") { d.remove(); f.removeClass("active hover") } else { if (c == "hide") { d.hide(); f.removeClass("active hover") } else { if (c == "show") { d.show() } } } }) } } } })(jQuery); var ZeroClipboard = { version: "1.0.7", clients: {}, moviePath: "ZeroClipboard.swf", nextId: 1, $: function (a) { if (typeof (a) == "string") { a = document.getElementById(a) } if (!a.addClass) { a.hide = function () { this.style.display = "none" }; a.show = function () { this.style.display = "" }; a.addClass = function (b) { this.removeClass(b); this.className += " " + b }; a.removeClass = function (d) { var e = this.className.split(/\s+/); var b = -1; for (var c = 0; c < e.length; c++) { if (e[c] == d) { b = c; c = e.length } } if (b > -1) { e.splice(b, 1); this.className = e.join(" ") } return this }; a.hasClass = function (b) { return !!this.className.match(new RegExp("\\s*" + b + "\\s*")) } } return a }, setMoviePath: function (a) { this.moviePath = a }, dispatch: function (d, b, c) { var a = this.clients[d]; if (a) { a.receiveEvent(b, c) } }, register: function (b, a) { this.clients[b] = a }, getDOMObjectPosition: function (c, a) { var b = { left: 0, top: 0, width: c.width ? c.width : c.offsetWidth, height: c.height ? c.height : c.offsetHeight }; if (c && (c != a)) { b.left += c.offsetLeft; b.top += c.offsetTop } return b }, Client: function (a) { this.handlers = {}; this.id = ZeroClipboard.nextId++; this.movieId = "ZeroClipboardMovie_" + this.id; ZeroClipboard.register(this.id, this); if (a) { this.glue(a) } } }; ZeroClipboard.Client.prototype = { id: 0, ready: false, movie: null, clipText: "", handCursorEnabled: true, cssEffects: true, handlers: null, glue: function (d, b, e) { this.domElement = ZeroClipboard.$(d); var f = 99; if (this.domElement.style.zIndex) { f = parseInt(this.domElement.style.zIndex, 10) + 1 } if (typeof (b) == "string") { b = ZeroClipboard.$(b) } else { if (typeof (b) == "undefined") { b = document.getElementsByTagName("body")[0] } } var c = ZeroClipboard.getDOMObjectPosition(this.domElement, b); this.div = document.createElement("div"); this.div.className = "zclip"; this.div.id = "zclip-" + this.movieId; $(this.domElement).data("zclipId", "zclip-" + this.movieId); var a = this.div.style; a.position = "absolute"; a.left = "" + c.left + "px"; a.top = "" + c.top + "px"; a.width = "" + c.width + "px"; a.height = "" + c.height + "px"; a.zIndex = f; if (typeof (e) == "object") { for (addedStyle in e) { a[addedStyle] = e[addedStyle] } } b.appendChild(this.div); this.div.innerHTML = this.getHTML(c.width, c.height) }, getHTML: function (d, a) { var c = ""; var b = "id=" + this.id + "&width=" + d + "&height=" + a; if (navigator.userAgent.match(/MSIE/)) { var e = location.href.match(/^https/i) ? "https://" : "http://"; c += '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="' + e + 'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" width="' + d + '" height="' + a + '" id="' + this.movieId + '" align="middle"><param name="allowScriptAccess" value="always" /><param name="allowFullScreen" value="false" /><param name="movie" value="' + ZeroClipboard.moviePath + '" /><param name="loop" value="false" /><param name="menu" value="false" /><param name="quality" value="best" /><param name="bgcolor" value="#ffffff" /><param name="flashvars" value="' + b + '"/><param name="wmode" value="transparent"/></object>' } else { c += '<embed id="' + this.movieId + '" src="' + ZeroClipboard.moviePath + '" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="' + d + '" height="' + a + '" name="' + this.movieId + '" align="middle" allowScriptAccess="always" allowFullScreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="' + b + '" wmode="transparent" />' } return c }, hide: function () { if (this.div) { this.div.style.left = "-2000px" } }, show: function () { this.reposition() }, destroy: function () { if (this.domElement && this.div) { this.hide(); this.div.innerHTML = ""; var a = document.getElementsByTagName("body")[0]; try { a.removeChild(this.div) } catch (b) { } this.domElement = null; this.div = null } }, reposition: function (c) { if (c) { this.domElement = ZeroClipboard.$(c); if (!this.domElement) { this.hide() } } if (this.domElement && this.div) { var b = ZeroClipboard.getDOMObjectPosition(this.domElement); var a = this.div.style; a.left = "" + b.left + "px"; a.top = "" + b.top + "px" } }, setText: function (a) { this.clipText = a; if (this.ready) { this.movie.setText(a) } }, addEventListener: function (a, b) { a = a.toString().toLowerCase().replace(/^on/, ""); if (!this.handlers[a]) { this.handlers[a] = [] } this.handlers[a].push(b) }, setHandCursor: function (a) { this.handCursorEnabled = a; if (this.ready) { this.movie.setHandCursor(a) } }, setCSSEffects: function (a) { this.cssEffects = !!a }, receiveEvent: function (d, f) { d = d.toString().toLowerCase().replace(/^on/, ""); switch (d) { case "load": this.movie = document.getElementById(this.movieId); if (!this.movie) { var c = this; setTimeout(function () { c.receiveEvent("load", null) }, 1); return } if (!this.ready && navigator.userAgent.match(/Firefox/) && navigator.userAgent.match(/Windows/)) { var c = this; setTimeout(function () { c.receiveEvent("load", null) }, 100); this.ready = true; return } this.ready = true; try { this.movie.setText(this.clipText) } catch (h) { } try { this.movie.setHandCursor(this.handCursorEnabled) } catch (h) { } break; case "mouseover": if (this.domElement && this.cssEffects) { this.domElement.addClass("hover"); if (this.recoverActive) { this.domElement.addClass("active") } } break; case "mouseout": if (this.domElement && this.cssEffects) { this.recoverActive = false; if (this.domElement.hasClass("active")) { this.domElement.removeClass("active"); this.recoverActive = true } this.domElement.removeClass("hover") } break; case "mousedown": if (this.domElement && this.cssEffects) { this.domElement.addClass("active") } break; case "mouseup": if (this.domElement && this.cssEffects) { this.domElement.removeClass("active"); this.recoverActive = false } break } if (this.handlers[d]) { for (var b = 0, a = this.handlers[d].length; b < a; b++) { var g = this.handlers[d][b]; if (typeof (g) == "function") { g(this, f) } else { if ((typeof (g) == "object") && (g.length == 2)) { g[0][g[1]](this, f) } else { if (typeof (g) == "string") { window[g](this, f) } } } } } } };

jQuery.extend({
    __stringPrototype: {
        JSONFilter: /^\/\*-secure-([\s\S]*)\*\/\s*$/, ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script>', specialChar: { '\b': '\\b', '\t': '\\t', '\n': '\\n', '\f': '\\f', '\r': '\\r', '\\': '\\\\' }, blank: function (s) { return /^\s*$/.test(this.s(s) || ' '); }, camelize: function (s) {
            var a = this.s(s).split('-'), i; s = [a[0]]; for (i = 1; i < a.length; i++) { s.push(a[i].charAt(0).toUpperCase() + a[i].substring(1)); }
            s = s.join(''); return this.r(arguments, 0, s);
        }, capitalize: function (s) { s = this.s(s); s = s.charAt(0).toUpperCase() + s.substring(1).toLowerCase(); return this.r(arguments, 0, s); }, dasherize: function (s) { s = this.s(s).split('_').join('-'); return this.r(arguments, 0, s); }, empty: function (s) { return this.s(s) === ''; }, endsWith: function (pattern, s) { s = this.s(s); var d = s.length - pattern.length; return d >= 0 && s.lastIndexOf(pattern) === d; }, escapeHTML: function (s) { s = this.s(s).replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>'); return this.r(arguments, 0, s); }, evalJSON: function (sanitize, s) {
            s = this.s(s); var json = this.unfilterJSON(false, s); try { if (!sanitize || this.isJSON(json)) { return eval('(' + json + ')'); } } catch (e) { }
            throw new SyntaxError('Badly formed JSON string: ' + s);
        }, evalScripts: function (s) {
            var scriptTags = this.extractScripts(this.s(s)), results = []; if (scriptTags.length > 0) { for (var i = 0; i < scriptTags.length; i++) { results.push(eval(scriptTags[i])); } }
            return results;
        }, extractScripts: function (s) {
            var matchAll = new RegExp(this.ScriptFragment, 'img'), matchOne = new RegExp(this.ScriptFragment, 'im'), scriptMatches = this.s(s).match(matchAll) || [], scriptTags = []; if (scriptMatches.length > 0) { for (var i = 0; i < scriptMatches.length; i++) { scriptTags.push(scriptMatches[i].match(matchOne)[1] || ''); } }
            return scriptTags;
        }, gsub: function (pattern, replacement, s) {
            s = this.s(s); if (jQuery.isFunction(replacement)) { s = this.sub(pattern, replacement, -1, s); }
            else { s = s.split(pattern).join(replacement); }
            return this.r(arguments, 2, s);
        }, include: function (pattern, s) { return this.s(s).indexOf(pattern) > -1; }, inspect: function (useDoubleQuotes, s) {
            s = this.s(s); var escapedString; try { escapedString = this.sub(/[\x00-\x1f\\]/, function (match) { var character = jQuery.__stringPrototype.specialChar[match[0]]; return character ? character : '\\u00' + match[0].charCodeAt().toPaddedString(2, 16); }, -1, s); } catch (e) { escapedString = s; }
            s = (useDoubleQuotes) ? '"' + escapedString.replace(/"/g, '\\"') + '"' : "'" + escapedString.replace(/'/g, '\\\'') + "'"; return this.r(arguments, 1, s);
        }, interpolate: function (obj, pattern, s) {
            s = this.s(s); if (!pattern) { pattern = /(\#\{\s*(\w+)\s*\})/; }
            var gpattern = new RegExp(pattern.source, "g"); var matches = s.match(gpattern), i; for (i = 0; i < matches.length; i++) { s = s.replace(matches[i], obj[matches[i].match(pattern)[2]]); }
            return this.r(arguments, 2, s);
        }, isJSON: function (s) {
            s = this.s(s); if (this.blank(s)) { return false; }
            s = s.replace(/\\./g, '@').replace(/"[^"\\\n\r]*"/g, ''); return (/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/).test(s);
        }, scan: function (pattern, replacement, s) { s = this.s(s); this.sub(pattern, replacement, -1, s); return this.r(arguments, 2, s); }, startsWith: function (pattern, s) { return this.s(s).indexOf(pattern) === 0; }, strip: function (s) { s = jQuery.trim(this.s(s)); return this.r(arguments, 0, s); }, stripScripts: function (s) { s = this.s(s).replace(new RegExp(this.ScriptFragment, 'img'), ''); return this.r(arguments, 0, s); }, stripTags: function (s) { s = this.s(s).replace(/<\/?[^>]+>/gi, ''); return this.r(arguments, 0, s); }, sub: function (pattern, replacement, count, s) {
            s = this.s(s); if (pattern.source && !pattern.global) { var patternMods = (pattern.ignoreCase) ? "ig" : "g"; patternMods += (pattern.multiline) ? "m" : ""; pattern = new RegExp(pattern.source, patternMods); }
            var sarray = s.split(pattern), matches = s.match(pattern); if (jQuery.browser.msie) { if (s.indexOf(matches[0]) == 0) sarray.unshift(""); if (s.lastIndexOf(matches[matches.length - 1]) == s.length - matches[matches.length - 1].length) sarray.push(""); }
            count = (count < 0) ? (sarray.length - 1) : count || 1; s = sarray[0]; for (var i = 1; i < sarray.length; i++) { if (i <= count) { if (jQuery.isFunction(replacement)) { s += replacement(matches[i - 1] || matches) + sarray[i]; } else { s += replacement + sarray[i]; } } else { s += (matches[i - 1] || matches) + sarray[i]; } }
            return this.r(arguments, 3, s);
        }, succ: function (s) { s = this.s(s); s = s.slice(0, s.length - 1) + String.fromCharCode(s.charCodeAt(s.length - 1) + 1); return this.r(arguments, 0, s); }, times: function (count, s) {
            s = this.s(s); var newS = ""; for (var i = 0; i < count; i++) { newS += s; }
            return this.r(arguments, 1, newS);
        }, toJSON: function (s) { return this.r(arguments, 0, this.inspect(true, this.s(s))); }, toQueryParams: function (separator, s) {
            s = this.s(s); var paramsList = s.substring(s.indexOf('?') + 1).split('#')[0].split(separator || '&'), params = {}, i, key, value, pair; for (i = 0; i < paramsList.length; i++) {
                pair = paramsList[i].split('='); key = decodeURIComponent(pair[0]); value = (pair[1]) ? decodeURIComponent(pair[1]) : undefined; if (params[key]) {
                    if (typeof params[key] == "string") { params[key] = [params[key]]; }
                    params[key].push(value);
                } else { params[key] = value; }
            }
            return params;
        }, truncate: function (length, truncation, s) { s = this.s(s); length = length || 30; truncation = (!truncation) ? '...' : truncation; s = (s.length > length) ? s.slice(0, length - truncation.length) + truncation : String(s); return this.r(arguments, 2, s); }, underscore: function (s) { s = this.sub(/[A-Z]/, function (c) { return "_" + c.toLowerCase(); }, -1, this.s(s)); if (s.charAt(0) == "_") s = s.substring(1); return this.r(arguments, 0, s); }, unescapeHTML: function (s) { s = this.stripTags(this.s(s)).replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>'); return this.r(arguments, 0, s); }, unfilterJSON: function (filter, s) { s = this.s(s); filter = filter || this.JSONFilter; var filtered = s.match(filter); s = (filtered !== null) ? filtered[1] : s; return this.r(arguments, 1, jQuery.trim(s)); }, r: function (args, size, s) { if (args.length > size || this.str === undefined) { return s; } else { this.str = '' + s; return this; }; }, s: function (s) {
            if (s === '' || s) { return s; }
            if (this.str === '' || this.str) { return this.str; }
            return this;
        }
    }, string: function (str) {
        if (str === String.prototype) { jQuery.extend(String.prototype, jQuery.__stringPrototype); }
        else { return jQuery.extend({ str: str }, jQuery.__stringPrototype); }
    }
}); jQuery.__stringPrototype.parseQuery = jQuery.__stringPrototype.toQueryParams;

var q = null; window.PR_SHOULD_USE_CONTINUATION = !0;
(function () {
    function L(a) {
        function m(a) { var f = a.charCodeAt(0); if (f !== 92) return f; var b = a.charAt(1); return (f = r[b]) ? f : "0" <= b && b <= "7" ? parseInt(a.substring(1), 8) : b === "u" || b === "x" ? parseInt(a.substring(2), 16) : a.charCodeAt(1) } function e(a) { if (a < 32) return (a < 16 ? "\\x0" : "\\x") + a.toString(16); a = String.fromCharCode(a); if (a === "\\" || a === "-" || a === "[" || a === "]") a = "\\" + a; return a } function h(a) {
            for (var f = a.substring(1, a.length - 1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g), a =
            [], b = [], o = f[0] === "^", c = o ? 1 : 0, i = f.length; c < i; ++c) { var j = f[c]; if (/\\[bdsw]/i.test(j)) a.push(j); else { var j = m(j), d; c + 2 < i && "-" === f[c + 1] ? (d = m(f[c + 2]), c += 2) : d = j; b.push([j, d]); d < 65 || j > 122 || (d < 65 || j > 90 || b.push([Math.max(65, j) | 32, Math.min(d, 90) | 32]), d < 97 || j > 122 || b.push([Math.max(97, j) & -33, Math.min(d, 122) & -33])) } } b.sort(function (a, f) { return a[0] - f[0] || f[1] - a[1] }); f = []; j = [NaN, NaN]; for (c = 0; c < b.length; ++c) i = b[c], i[0] <= j[1] + 1 ? j[1] = Math.max(j[1], i[1]) : f.push(j = i); b = ["["]; o && b.push("^"); b.push.apply(b, a); for (c = 0; c <
            f.length; ++c) i = f[c], b.push(e(i[0])), i[1] > i[0] && (i[1] + 1 > i[0] && b.push("-"), b.push(e(i[1]))); b.push("]"); return b.join("")
        } function y(a) {
            for (var f = a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g), b = f.length, d = [], c = 0, i = 0; c < b; ++c) { var j = f[c]; j === "(" ? ++i : "\\" === j.charAt(0) && (j = +j.substring(1)) && j <= i && (d[j] = -1) } for (c = 1; c < d.length; ++c) -1 === d[c] && (d[c] = ++t); for (i = c = 0; c < b; ++c) j = f[c], j === "(" ? (++i, d[i] === void 0 && (f[c] = "(?:")) : "\\" === j.charAt(0) &&
            (j = +j.substring(1)) && j <= i && (f[c] = "\\" + d[i]); for (i = c = 0; c < b; ++c) "^" === f[c] && "^" !== f[c + 1] && (f[c] = ""); if (a.ignoreCase && s) for (c = 0; c < b; ++c) j = f[c], a = j.charAt(0), j.length >= 2 && a === "[" ? f[c] = h(j) : a !== "\\" && (f[c] = j.replace(/[A-Za-z]/g, function (a) { a = a.charCodeAt(0); return "[" + String.fromCharCode(a & -33, a | 32) + "]" })); return f.join("")
        } for (var t = 0, s = !1, l = !1, p = 0, d = a.length; p < d; ++p) { var g = a[p]; if (g.ignoreCase) l = !0; else if (/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi, ""))) { s = !0; l = !1; break } } for (var r =
        { b: 8, t: 9, n: 10, v: 11, f: 12, r: 13 }, n = [], p = 0, d = a.length; p < d; ++p) { g = a[p]; if (g.global || g.multiline) throw Error("" + g); n.push("(?:" + y(g) + ")") } return RegExp(n.join("|"), l ? "gi" : "g")
    } function M(a) {
        function m(a) {
            switch (a.nodeType) {
                case 1: if (e.test(a.className)) break; for (var g = a.firstChild; g; g = g.nextSibling) m(g); g = a.nodeName; if ("BR" === g || "LI" === g) h[s] = "\n", t[s << 1] = y++, t[s++ << 1 | 1] = a; break; case 3: case 4: g = a.nodeValue, g.length && (g = p ? g.replace(/\r\n?/g, "\n") : g.replace(/[\t\n\r ]+/g, " "), h[s] = g, t[s << 1] = y, y += g.length,
                t[s++ << 1 | 1] = a)
            }
        } var e = /(?:^|\s)nocode(?:\s|$)/, h = [], y = 0, t = [], s = 0, l; a.currentStyle ? l = a.currentStyle.whiteSpace : window.getComputedStyle && (l = document.defaultView.getComputedStyle(a, q).getPropertyValue("white-space")); var p = l && "pre" === l.substring(0, 3); m(a); return { a: h.join("").replace(/\n$/, ""), c: t }
    } function B(a, m, e, h) { m && (a = { a: m, d: a }, e(a), h.push.apply(h, a.e)) } function x(a, m) {
        function e(a) {
            for (var l = a.d, p = [l, "pln"], d = 0, g = a.a.match(y) || [], r = {}, n = 0, z = g.length; n < z; ++n) {
                var f = g[n], b = r[f], o = void 0, c; if (typeof b ===
                "string") c = !1; else { var i = h[f.charAt(0)]; if (i) o = f.match(i[1]), b = i[0]; else { for (c = 0; c < t; ++c) if (i = m[c], o = f.match(i[1])) { b = i[0]; break } o || (b = "pln") } if ((c = b.length >= 5 && "lang-" === b.substring(0, 5)) && !(o && typeof o[1] === "string")) c = !1, b = "src"; c || (r[f] = b) } i = d; d += f.length; if (c) { c = o[1]; var j = f.indexOf(c), k = j + c.length; o[2] && (k = f.length - o[2].length, j = k - c.length); b = b.substring(5); B(l + i, f.substring(0, j), e, p); B(l + i + j, c, C(b, c), p); B(l + i + k, f.substring(k), e, p) } else p.push(l + i, b)
            } a.e = p
        } var h = {}, y; (function () {
            for (var e = a.concat(m),
            l = [], p = {}, d = 0, g = e.length; d < g; ++d) { var r = e[d], n = r[3]; if (n) for (var k = n.length; --k >= 0;) h[n.charAt(k)] = r; r = r[1]; n = "" + r; p.hasOwnProperty(n) || (l.push(r), p[n] = q) } l.push(/[\S\s]/); y = L(l)
        })(); var t = m.length; return e
    } function u(a) {
        var m = [], e = []; a.tripleQuotedStrings ? m.push(["str", /^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/, q, "'\""]) : a.multiLineStrings ? m.push(["str", /^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
        q, "'\"`"]) : m.push(["str", /^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/, q, "\"'"]); a.verbatimStrings && e.push(["str", /^@"(?:[^"]|"")*(?:"|$)/, q]); var h = a.hashComments; h && (a.cStyleComments ? (h > 1 ? m.push(["com", /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, q, "#"]) : m.push(["com", /^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/, q, "#"]), e.push(["str", /^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/, q])) : m.push(["com", /^#[^\n\r]*/,
        q, "#"])); a.cStyleComments && (e.push(["com", /^\/\/[^\n\r]*/, q]), e.push(["com", /^\/\*[\S\s]*?(?:\*\/|$)/, q])); a.regexLiterals && e.push(["lang-regex", /^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]); (h = a.types) && e.push(["typ", h]); a = ("" + a.keywords).replace(/^ | $/g,
        ""); a.length && e.push(["kwd", RegExp("^(?:" + a.replace(/[\s,]+/g, "|") + ")\\b"), q]); m.push(["pln", /^\s+/, q, " \r\n\t\xa0"]); e.push(["lit", /^@[$_a-z][\w$@]*/i, q], ["typ", /^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/, q], ["pln", /^[$_a-z][\w$@]*/i, q], ["lit", /^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i, q, "0123456789"], ["pln", /^\\[\S\s]?/, q], ["pun", /^.[^\s\w"-$'./@\\`]*/, q]); return x(m, e)
    } function D(a, m) {
        function e(a) {
            switch (a.nodeType) {
                case 1: if (k.test(a.className)) break; if ("BR" === a.nodeName) h(a),
                a.parentNode && a.parentNode.removeChild(a); else for (a = a.firstChild; a; a = a.nextSibling) e(a); break; case 3: case 4: if (p) { var b = a.nodeValue, d = b.match(t); if (d) { var c = b.substring(0, d.index); a.nodeValue = c; (b = b.substring(d.index + d[0].length)) && a.parentNode.insertBefore(s.createTextNode(b), a.nextSibling); h(a); c || a.parentNode.removeChild(a) } }
            }
        } function h(a) {
            function b(a, d) { var e = d ? a.cloneNode(!1) : a, f = a.parentNode; if (f) { var f = b(f, 1), g = a.nextSibling; f.appendChild(e); for (var h = g; h; h = g) g = h.nextSibling, f.appendChild(h) } return e }
            for (; !a.nextSibling;) if (a = a.parentNode, !a) return; for (var a = b(a.nextSibling, 0), e; (e = a.parentNode) && e.nodeType === 1;) a = e; d.push(a)
        } var k = /(?:^|\s)nocode(?:\s|$)/, t = /\r\n?|\n/, s = a.ownerDocument, l; a.currentStyle ? l = a.currentStyle.whiteSpace : window.getComputedStyle && (l = s.defaultView.getComputedStyle(a, q).getPropertyValue("white-space")); var p = l && "pre" === l.substring(0, 3); for (l = s.createElement("LI") ; a.firstChild;) l.appendChild(a.firstChild); for (var d = [l], g = 0; g < d.length; ++g) e(d[g]); m === (m | 0) && d[0].setAttribute("value",
        m); var r = s.createElement("OL"); r.className = "linenums"; for (var n = Math.max(0, m - 1 | 0) || 0, g = 0, z = d.length; g < z; ++g) l = d[g], l.className = "L" + (g + n) % 10, l.firstChild || l.appendChild(s.createTextNode("\xa0")), r.appendChild(l); a.appendChild(r)
    } function k(a, m) { for (var e = m.length; --e >= 0;) { var h = m[e]; A.hasOwnProperty(h) ? window.console && console.warn("cannot override language handler %s", h) : A[h] = a } } function C(a, m) { if (!a || !A.hasOwnProperty(a)) a = /^\s*</.test(m) ? "default-markup" : "default-code"; return A[a] } function E(a) {
        var m =
        a.g; try {
            var e = M(a.h), h = e.a; a.a = h; a.c = e.c; a.d = 0; C(m, h)(a); var k = /\bMSIE\b/.test(navigator.userAgent), m = /\n/g, t = a.a, s = t.length, e = 0, l = a.c, p = l.length, h = 0, d = a.e, g = d.length, a = 0; d[g] = s; var r, n; for (n = r = 0; n < g;) d[n] !== d[n + 2] ? (d[r++] = d[n++], d[r++] = d[n++]) : n += 2; g = r; for (n = r = 0; n < g;) { for (var z = d[n], f = d[n + 1], b = n + 2; b + 2 <= g && d[b + 1] === f;) b += 2; d[r++] = z; d[r++] = f; n = b } for (d.length = r; h < p;) {
                var o = l[h + 2] || s, c = d[a + 2] || s, b = Math.min(o, c), i = l[h + 1], j; if (i.nodeType !== 1 && (j = t.substring(e, b))) {
                    k && (j = j.replace(m, "\r")); i.nodeValue =
                    j; var u = i.ownerDocument, v = u.createElement("SPAN"); v.className = d[a + 1]; var x = i.parentNode; x.replaceChild(v, i); v.appendChild(i); e < o && (l[h + 1] = i = u.createTextNode(t.substring(b, o)), x.insertBefore(i, v.nextSibling))
                } e = b; e >= o && (h += 2); e >= c && (a += 2)
            }
        } catch (w) { "console" in window && console.log(w && w.stack ? w.stack : w) }
    } var v = ["break,continue,do,else,for,if,return,while"], w = [[v, "auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
    "catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"], F = [w, "alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"], G = [w, "abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
    H = [G, "as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"], w = [w, "debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"], I = [v, "and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
    J = [v, "alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"], v = [v, "case,done,elif,esac,eval,fi,function,in,local,set,then,until"], K = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/, N = /\S/, O = u({
        keywords: [F, H, w, "caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END" +
        I, J, v], hashComments: !0, cStyleComments: !0, multiLineStrings: !0, regexLiterals: !0
    }), A = {}; k(O, ["default-code"]); k(x([], [["pln", /^[^<?]+/], ["dec", /^<!\w[^>]*(?:>|$)/], ["com", /^<\!--[\S\s]*?(?:--\>|$)/], ["lang-", /^<\?([\S\s]+?)(?:\?>|$)/], ["lang-", /^<%([\S\s]+?)(?:%>|$)/], ["pun", /^(?:<[%?]|[%?]>)/], ["lang-", /^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i], ["lang-js", /^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i], ["lang-css", /^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i], ["lang-in.tag", /^(<\/?[a-z][^<>]*>)/i]]),
    ["default-markup", "htm", "html", "mxml", "xhtml", "xml", "xsl"]); k(x([["pln", /^\s+/, q, " \t\r\n"], ["atv", /^(?:"[^"]*"?|'[^']*'?)/, q, "\"'"]], [["tag", /^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i], ["atn", /^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i], ["lang-uq.val", /^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/], ["pun", /^[/<->]+/], ["lang-js", /^on\w+\s*=\s*"([^"]+)"/i], ["lang-js", /^on\w+\s*=\s*'([^']+)'/i], ["lang-js", /^on\w+\s*=\s*([^\s"'>]+)/i], ["lang-css", /^style\s*=\s*"([^"]+)"/i], ["lang-css", /^style\s*=\s*'([^']+)'/i], ["lang-css",
    /^style\s*=\s*([^\s"'>]+)/i]]), ["in.tag"]); k(x([], [["atv", /^[\S\s]+/]]), ["uq.val"]); k(u({ keywords: F, hashComments: !0, cStyleComments: !0, types: K }), ["c", "cc", "cpp", "cxx", "cyc", "m"]); k(u({ keywords: "null,true,false" }), ["json"]); k(u({ keywords: H, hashComments: !0, cStyleComments: !0, verbatimStrings: !0, types: K }), ["cs"]); k(u({ keywords: G, cStyleComments: !0 }), ["java"]); k(u({ keywords: v, hashComments: !0, multiLineStrings: !0 }), ["bsh", "csh", "sh"]); k(u({ keywords: I, hashComments: !0, multiLineStrings: !0, tripleQuotedStrings: !0 }),
    ["cv", "py"]); k(u({ keywords: "caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END", hashComments: !0, multiLineStrings: !0, regexLiterals: !0 }), ["perl", "pl", "pm"]); k(u({ keywords: J, hashComments: !0, multiLineStrings: !0, regexLiterals: !0 }), ["rb"]); k(u({ keywords: w, cStyleComments: !0, regexLiterals: !0 }), ["js"]); k(u({
        keywords: "all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
        hashComments: 3, cStyleComments: !0, multilineStrings: !0, tripleQuotedStrings: !0, regexLiterals: !0
    }), ["coffee"]); k(x([], [["str", /^[\S\s]+/]]), ["regex"]); window.prettyPrintOne = function (a, m, e) { var h = document.createElement("PRE"); h.innerHTML = a; e && D(h, e); E({ g: m, i: e, h: h }); return h.innerHTML }; window.prettyPrint = function (a) {
        function m() {
            for (var e = window.PR_SHOULD_USE_CONTINUATION ? l.now() + 250 : Infinity; p < h.length && l.now() < e; p++) {
                var n = h[p], k = n.className; if (k.indexOf("prettyprint") >= 0) {
                    var k = k.match(g), f, b; if (b =
                    !k) { b = n; for (var o = void 0, c = b.firstChild; c; c = c.nextSibling) var i = c.nodeType, o = i === 1 ? o ? b : c : i === 3 ? N.test(c.nodeValue) ? b : o : o; b = (f = o === b ? void 0 : o) && "CODE" === f.tagName } b && (k = f.className.match(g)); k && (k = k[1]); b = !1; for (o = n.parentNode; o; o = o.parentNode) if ((o.tagName === "pre" || o.tagName === "code" || o.tagName === "xmp") && o.className && o.className.indexOf("prettyprint") >= 0) { b = !0; break } b || ((b = (b = n.className.match(/\blinenums\b(?::(\d+))?/)) ? b[1] && b[1].length ? +b[1] : !0 : !1) && D(n, b), d = { g: k, h: n, i: b }, E(d))
                }
            } p < h.length ? setTimeout(m,
            250) : a && a()
        } for (var e = [document.getElementsByTagName("pre"), document.getElementsByTagName("code"), document.getElementsByTagName("xmp")], h = [], k = 0; k < e.length; ++k) for (var t = 0, s = e[k].length; t < s; ++t) h.push(e[k][t]); var e = q, l = Date; l.now || (l = { now: function () { return +new Date } }); var p = 0, d, g = /\blang(?:uage)?-([\w.]+)(?!\S)/; m()
    }; window.PR = {
        createSimpleLexer: x, registerLangHandler: k, sourceDecorator: u, PR_ATTRIB_NAME: "atn", PR_ATTRIB_VALUE: "atv", PR_COMMENT: "com", PR_DECLARATION: "dec", PR_KEYWORD: "kwd", PR_LITERAL: "lit",
        PR_NOCODE: "nocode", PR_PLAIN: "pln", PR_PUNCTUATION: "pun", PR_SOURCE: "src", PR_STRING: "str", PR_TAG: "tag", PR_TYPE: "typ"
    }
})();

(function ($) {
    $.extend({
        tablesorter: new
        function () {
            var parsers = [], widgets = []; this.defaults = { cssHeader: "header", cssAsc: "headerSortUp", cssDesc: "headerSortDown", cssChildRow: "expand-child", sortInitialOrder: "asc", sortMultiSortKey: "shiftKey", sortForce: null, sortAppend: null, sortLocaleCompare: true, textExtraction: "simple", parsers: {}, widgets: [], widgetZebra: { css: ["even", "odd"] }, headers: {}, widthFixed: false, cancelSelection: true, sortList: [], headerList: [], dateFormat: "us", decimal: '/\.|\,/g', onRenderHeader: null, selectorHeaders: 'thead th', debug: false }; function benchmark(s, d) { log(s + "," + (new Date().getTime() - d.getTime()) + "ms"); } this.benchmark = benchmark; function log(s) { if (typeof console != "undefined" && typeof console.debug != "undefined") { console.log(s); } else { alert(s); } } function buildParserCache(table, $headers) { if (table.config.debug) { var parsersDebug = ""; } if (table.tBodies.length == 0) return; var rows = table.tBodies[0].rows; if (rows[0]) { var list = [], cells = rows[0].cells, l = cells.length; for (var i = 0; i < l; i++) { var p = false; if ($.metadata && ($($headers[i]).metadata() && $($headers[i]).metadata().sorter)) { p = getParserById($($headers[i]).metadata().sorter); } else if ((table.config.headers[i] && table.config.headers[i].sorter)) { p = getParserById(table.config.headers[i].sorter); } if (!p) { p = detectParserForColumn(table, rows, -1, i); } if (table.config.debug) { parsersDebug += "column:" + i + " parser:" + p.id + "\n"; } list.push(p); } } if (table.config.debug) { log(parsersDebug); } return list; }; function detectParserForColumn(table, rows, rowIndex, cellIndex) { var l = parsers.length, node = false, nodeValue = false, keepLooking = true; while (nodeValue == '' && keepLooking) { rowIndex++; if (rows[rowIndex]) { node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex); nodeValue = trimAndGetNodeText(table.config, node); if (table.config.debug) { log('Checking if value was empty on row:' + rowIndex); } } else { keepLooking = false; } } for (var i = 1; i < l; i++) { if (parsers[i].is(nodeValue, table, node)) { return parsers[i]; } } return parsers[0]; } function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) { return rows[rowIndex].cells[cellIndex]; } function trimAndGetNodeText(config, node) { return $.trim(getElementText(config, node)); } function getParserById(name) { var l = parsers.length; for (var i = 0; i < l; i++) { if (parsers[i].id.toLowerCase() == name.toLowerCase()) { return parsers[i]; } } return false; } function buildCache(table) { if (table.config.debug) { var cacheTime = new Date(); } var totalRows = (table.tBodies[0] && table.tBodies[0].rows.length) || 0, totalCells = (table.tBodies[0].rows[0] && table.tBodies[0].rows[0].cells.length) || 0, parsers = table.config.parsers, cache = { row: [], normalized: [] }; for (var i = 0; i < totalRows; ++i) { var c = $(table.tBodies[0].rows[i]), cols = []; if (c.hasClass(table.config.cssChildRow)) { cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c); continue; } cache.row.push(c); for (var j = 0; j < totalCells; ++j) { cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j])); } cols.push(cache.normalized.length); cache.normalized.push(cols); cols = null; }; if (table.config.debug) { benchmark("Building cache for " + totalRows + " rows:", cacheTime); } return cache; }; function getElementText(config, node) { var text = ""; if (!node) return ""; if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false; if (config.textExtraction == "simple") { if (config.supportsTextContent) { text = node.textContent; } else { if (node.childNodes[0] && node.childNodes[0].hasChildNodes()) { text = node.childNodes[0].innerHTML; } else { text = node.innerHTML; } } } else { if (typeof (config.textExtraction) == "function") { text = config.textExtraction(node); } else { text = $(node).text(); } } return text; } function appendToTable(table, cache) { if (table.config.debug) { var appendTime = new Date() } var c = cache, r = c.row, n = c.normalized, totalRows = n.length, checkCell = (n[0].length - 1), tableBody = $(table.tBodies[0]), rows = []; for (var i = 0; i < totalRows; i++) { var pos = n[i][checkCell]; rows.push(r[pos]); if (!table.config.appender) { var l = r[pos].length; for (var j = 0; j < l; j++) { tableBody[0].appendChild(r[pos][j]); } } } if (table.config.appender) { table.config.appender(table, rows); } rows = null; if (table.config.debug) { benchmark("Rebuilt table:", appendTime); } applyWidget(table); setTimeout(function () { $(table).trigger("sortEnd"); }, 0); }; function buildHeaders(table) { if (table.config.debug) { var time = new Date(); } var meta = ($.metadata) ? true : false; var header_index = computeTableHeaderCellIndexes(table); $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) { this.column = header_index[this.parentNode.rowIndex + "-" + this.cellIndex]; this.order = formatSortingOrder(table.config.sortInitialOrder); this.count = this.order; if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true; if (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index); if (!this.sortDisabled) { var $th = $(this).addClass(table.config.cssHeader); if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th); } table.config.headerList[index] = this; }); if (table.config.debug) { benchmark("Built headers:", time); log($tableHeaders); } return $tableHeaders; }; function computeTableHeaderCellIndexes(t) {
                var matrix = []; var lookup = {}; var thead = t.getElementsByTagName('THEAD')[0]; var trs = thead.getElementsByTagName('TR'); for (var i = 0; i < trs.length; i++) {
                    var cells = trs[i].cells; for (var j = 0; j < cells.length; j++) {
                        var c = cells[j]; var rowIndex = c.parentNode.rowIndex; var cellId = rowIndex + "-" + c.cellIndex; var rowSpan = c.rowSpan || 1; var colSpan = c.colSpan || 1
                        var firstAvailCol; if (typeof (matrix[rowIndex]) == "undefined") { matrix[rowIndex] = []; } for (var k = 0; k < matrix[rowIndex].length + 1; k++) { if (typeof (matrix[rowIndex][k]) == "undefined") { firstAvailCol = k; break; } } lookup[cellId] = firstAvailCol; for (var k = rowIndex; k < rowIndex + rowSpan; k++) { if (typeof (matrix[k]) == "undefined") { matrix[k] = []; } var matrixrow = matrix[k]; for (var l = firstAvailCol; l < firstAvailCol + colSpan; l++) { matrixrow[l] = "x"; } }
                    }
                } return lookup;
            } function checkCellColSpan(table, rows, row) { var arr = [], r = table.tHead.rows, c = r[row].cells; for (var i = 0; i < c.length; i++) { var cell = c[i]; if (cell.colSpan > 1) { arr = arr.concat(checkCellColSpan(table, headerArr, row++)); } else { if (table.tHead.length == 1 || (cell.rowSpan > 1 || !r[row + 1])) { arr.push(cell); } } } return arr; }; function checkHeaderMetadata(cell) { if (($.metadata) && ($(cell).metadata().sorter === false)) { return true; }; return false; } function checkHeaderOptions(table, i) { if ((table.config.headers[i]) && (table.config.headers[i].sorter === false)) { return true; }; return false; } function checkHeaderOptionsSortingLocked(table, i) { if ((table.config.headers[i]) && (table.config.headers[i].lockedOrder)) return table.config.headers[i].lockedOrder; return false; } function applyWidget(table) { var c = table.config.widgets; var l = c.length; for (var i = 0; i < l; i++) { getWidgetById(c[i]).format(table); } } function getWidgetById(name) { var l = widgets.length; for (var i = 0; i < l; i++) { if (widgets[i].id.toLowerCase() == name.toLowerCase()) { return widgets[i]; } } }; function formatSortingOrder(v) { if (typeof (v) != "Number") { return (v.toLowerCase() == "desc") ? 1 : 0; } else { return (v == 1) ? 1 : 0; } } function isValueInArray(v, a) { var l = a.length; for (var i = 0; i < l; i++) { if (a[i][0] == v) { return true; } } return false; } function setHeadersCss(table, $headers, list, css) { $headers.removeClass(css[0]).removeClass(css[1]); var h = []; $headers.each(function (offset) { if (!this.sortDisabled) { h[this.column] = $(this); } }); var l = list.length; for (var i = 0; i < l; i++) { h[list[i][0]].addClass(css[list[i][1]]); } } function fixColumnWidth(table, $headers) { var c = table.config; if (c.widthFixed) { var colgroup = $('<colgroup>'); $("tr:first td", table.tBodies[0]).each(function () { colgroup.append($('<col>').css('width', $(this).width())); }); $(table).prepend(colgroup); }; } function updateHeaderSortCount(table, sortList) { var c = table.config, l = sortList.length; for (var i = 0; i < l; i++) { var s = sortList[i], o = c.headerList[s[0]]; o.count = s[1]; o.count++; } } function multisort(table, sortList, cache) { if (table.config.debug) { var sortTime = new Date(); } var dynamicExp = "var sortWrapper = function(a,b) {", l = sortList.length; for (var i = 0; i < l; i++) { var c = sortList[i][0]; var order = sortList[i][1]; var s = (table.config.parsers[c].type == "text") ? ((order == 0) ? makeSortFunction("text", "asc", c) : makeSortFunction("text", "desc", c)) : ((order == 0) ? makeSortFunction("numeric", "asc", c) : makeSortFunction("numeric", "desc", c)); var e = "e" + i; dynamicExp += "var " + e + " = " + s; dynamicExp += "if(" + e + ") { return " + e + "; } "; dynamicExp += "else { "; } var orgOrderCol = cache.normalized[0].length - 1; dynamicExp += "return a[" + orgOrderCol + "]-b[" + orgOrderCol + "];"; for (var i = 0; i < l; i++) { dynamicExp += "}; "; } dynamicExp += "return 0; "; dynamicExp += "}; "; if (table.config.debug) { benchmark("Evaling expression:" + dynamicExp, new Date()); } eval(dynamicExp); cache.normalized.sort(sortWrapper); if (table.config.debug) { benchmark("Sorting on " + sortList.toString() + " and dir " + order + " time:", sortTime); } return cache; }; function makeSortFunction(type, direction, index) { var a = "a[" + index + "]", b = "b[" + index + "]"; if (type == 'text' && direction == 'asc') { return "(" + a + " == " + b + " ? 0 : (" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : (" + a + " < " + b + ") ? -1 : 1 )));"; } else if (type == 'text' && direction == 'desc') { return "(" + a + " == " + b + " ? 0 : (" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : (" + b + " < " + a + ") ? -1 : 1 )));"; } else if (type == 'numeric' && direction == 'asc') { return "(" + a + " === null && " + b + " === null) ? 0 :(" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : " + a + " - " + b + "));"; } else if (type == 'numeric' && direction == 'desc') { return "(" + a + " === null && " + b + " === null) ? 0 :(" + a + " === null ? Number.POSITIVE_INFINITY : (" + b + " === null ? Number.NEGATIVE_INFINITY : " + b + " - " + a + "));"; } }; function makeSortText(i) { return "((a[" + i + "] < b[" + i + "]) ? -1 : ((a[" + i + "] > b[" + i + "]) ? 1 : 0));"; }; function makeSortTextDesc(i) { return "((b[" + i + "] < a[" + i + "]) ? -1 : ((b[" + i + "] > a[" + i + "]) ? 1 : 0));"; }; function makeSortNumeric(i) { return "a[" + i + "]-b[" + i + "];"; }; function makeSortNumericDesc(i) { return "b[" + i + "]-a[" + i + "];"; }; function sortText(a, b) { if (table.config.sortLocaleCompare) return a.localeCompare(b); return ((a < b) ? -1 : ((a > b) ? 1 : 0)); }; function sortTextDesc(a, b) { if (table.config.sortLocaleCompare) return b.localeCompare(a); return ((b < a) ? -1 : ((b > a) ? 1 : 0)); }; function sortNumeric(a, b) { return a - b; }; function sortNumericDesc(a, b) { return b - a; }; function getCachedSortType(parsers, i) { return parsers[i].type; }; this.construct = function (settings) { return this.each(function () { if (!this.tHead || !this.tBodies) return; var $this, $document, $headers, cache, config, shiftDown = 0, sortOrder; this.config = {}; config = $.extend(this.config, $.tablesorter.defaults, settings); $this = $(this); $.data(this, "tablesorter", config); $headers = buildHeaders(this); this.config.parsers = buildParserCache(this, $headers); cache = buildCache(this); var sortCSS = [config.cssDesc, config.cssAsc]; fixColumnWidth(this); $headers.click(function (e) { var totalRows = ($this[0].tBodies[0] && $this[0].tBodies[0].rows.length) || 0; if (!this.sortDisabled && totalRows > 0) { $this.trigger("sortStart"); var $cell = $(this); var i = this.column; this.order = this.count++ % 2; if (this.lockedOrder) this.order = this.lockedOrder; if (!e[config.sortMultiSortKey]) { config.sortList = []; if (config.sortForce != null) { var a = config.sortForce; for (var j = 0; j < a.length; j++) { if (a[j][0] != i) { config.sortList.push(a[j]); } } } config.sortList.push([i, this.order]); } else { if (isValueInArray(i, config.sortList)) { for (var j = 0; j < config.sortList.length; j++) { var s = config.sortList[j], o = config.headerList[s[0]]; if (s[0] == i) { o.count = s[1]; o.count++; s[1] = o.count % 2; } } } else { config.sortList.push([i, this.order]); } }; setTimeout(function () { setHeadersCss($this[0], $headers, config.sortList, sortCSS); appendToTable($this[0], multisort($this[0], config.sortList, cache)); }, 1); return false; } }).mousedown(function () { if (config.cancelSelection) { this.onselectstart = function () { return false }; return false; } }); $this.bind("update", function () { var me = this; setTimeout(function () { me.config.parsers = buildParserCache(me, $headers); cache = buildCache(me); }, 1); }).bind("updateCell", function (e, cell) { var config = this.config; var pos = [(cell.parentNode.rowIndex - 1), cell.cellIndex]; cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(getElementText(config, cell), cell); }).bind("sorton", function (e, list) { $(this).trigger("sortStart"); config.sortList = list; var sortList = config.sortList; updateHeaderSortCount(this, sortList); setHeadersCss(this, $headers, sortList, sortCSS); appendToTable(this, multisort(this, sortList, cache)); }).bind("appendCache", function () { appendToTable(this, cache); }).bind("applyWidgetId", function (e, id) { getWidgetById(id).format(this); }).bind("applyWidgets", function () { applyWidget(this); }); if ($.metadata && ($(this).metadata() && $(this).metadata().sortlist)) { config.sortList = $(this).metadata().sortlist; } if (config.sortList.length > 0) { $this.trigger("sorton", [config.sortList]); } applyWidget(this); }); }; this.addParser = function (parser) { var l = parsers.length, a = true; for (var i = 0; i < l; i++) { if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) { a = false; } } if (a) { parsers.push(parser); }; }; this.addWidget = function (widget) { widgets.push(widget); }; this.formatFloat = function (s) { var i = parseFloat(s); return (isNaN(i)) ? 0 : i; }; this.formatInt = function (s) { var i = parseInt(s); return (isNaN(i)) ? 0 : i; }; this.isDigit = function (s, config) { return /^[-+]?\d*$/.test($.trim(s.replace(/[,.']/g, ''))); }; this.clearTableBody = function (table) { if ($.browser.msie) { function empty() { while (this.firstChild) this.removeChild(this.firstChild); } empty.apply(table.tBodies[0]); } else { table.tBodies[0].innerHTML = ""; } };
        }
    }); $.fn.extend({ tablesorter: $.tablesorter.construct }); var ts = $.tablesorter; ts.addParser({ id: "text", is: function (s) { return true; }, format: function (s) { return $.trim(s.toLocaleLowerCase()); }, type: "text" }); ts.addParser({ id: "digit", is: function (s, table) { var c = table.config; return $.tablesorter.isDigit(s, c); }, format: function (s) { return $.tablesorter.formatFloat(s); }, type: "numeric" }); ts.addParser({ id: "currency", is: function (s) { return /^[£$€?.]/.test(s); }, format: function (s) { return $.tablesorter.formatFloat(s.replace(new RegExp(/[£$€]/g), "")); }, type: "numeric" }); ts.addParser({ id: "ipAddress", is: function (s) { return /^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s); }, format: function (s) { var a = s.split("."), r = "", l = a.length; for (var i = 0; i < l; i++) { var item = a[i]; if (item.length == 2) { r += "0" + item; } else { r += item; } } return $.tablesorter.formatFloat(r); }, type: "numeric" }); ts.addParser({ id: "url", is: function (s) { return /^(https?|ftp|file):\/\/$/.test(s); }, format: function (s) { return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//), '')); }, type: "text" }); ts.addParser({ id: "isoDate", is: function (s) { return /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s); }, format: function (s) { return $.tablesorter.formatFloat((s != "") ? new Date(s.replace(new RegExp(/-/g), "/")).getTime() : "0"); }, type: "numeric" }); ts.addParser({ id: "percent", is: function (s) { return /\%$/.test($.trim(s)); }, format: function (s) { return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g), "")); }, type: "numeric" }); ts.addParser({ id: "usLongDate", is: function (s) { return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/)); }, format: function (s) { return $.tablesorter.formatFloat(new Date(s).getTime()); }, type: "numeric" }); ts.addParser({ id: "shortDate", is: function (s) { return /\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s); }, format: function (s, table) { var c = table.config; s = s.replace(/\-/g, "/"); if (c.dateFormat == "us") { s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$1/$2"); } else if (c.dateFormat == "uk") { s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, "$3/$2/$1"); } else if (c.dateFormat == "dd/mm/yy" || c.dateFormat == "dd-mm-yy") { s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/, "$1/$2/$3"); } return $.tablesorter.formatFloat(new Date(s).getTime()); }, type: "numeric" }); ts.addParser({ id: "time", is: function (s) { return /^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s); }, format: function (s) { return $.tablesorter.formatFloat(new Date("2000/01/01 " + s).getTime()); }, type: "numeric" }); ts.addParser({ id: "metadata", is: function (s) { return false; }, format: function (s, table, cell) { var c = table.config, p = (!c.parserMetadataName) ? 'sortValue' : c.parserMetadataName; return $(cell).metadata()[p]; }, type: "numeric" }); ts.addWidget({ id: "zebra", format: function (table) { if (table.config.debug) { var time = new Date(); } var $tr, row = -1, odd; $("tr:visible", table.tBodies[0]).each(function (i) { $tr = $(this); if (!$tr.hasClass(table.config.cssChildRow)) row++; odd = (row % 2 == 0); $tr.removeClass(table.config.widgetZebra.css[odd ? 0 : 1]).addClass(table.config.widgetZebra.css[odd ? 1 : 0]) }); if (table.config.debug) { $.tablesorter.benchmark("Applying Zebra widget", time); } } });
})(jQuery);

function AddOrSubtractTwoFloats(fltValue1, fltValue2, bAddSubtract) {
    var strNumber1 = fltValue1.toString(); var strNumber2 = fltValue2.toString(); var strResult = ""; if (strNumber1.indexOf(".") > -1 || strNumber2.indexOf(".") > -1) {
        if (strNumber1.indexOf(".") == -1) { strNumber1 = strNumber1 + ".0"; }
        if (strNumber2.indexOf(".") == -1) { strNumber2 = strNumber2 + ".0"; }
        var strDecimals1 = strNumber1.substr(strNumber1.indexOf(".") + 1); var strDecimals2 = strNumber2.substr(strNumber2.indexOf(".") + 1); var strInteger1 = strNumber1.substr(0, strNumber1.indexOf(".")); var strInteger2 = strNumber2.substr(0, strNumber2.indexOf(".")); var bNotSameLength = true; while (bNotSameLength) { if (strDecimals1.length != strDecimals2.length) { if (strDecimals1.length < strDecimals2.length) { strDecimals1 += "0"; } else { strDecimals2 += "0"; } } else { bNotSameLength = false; } }
        var intOriginalDecimalLength = strDecimals1.length; for (var intCharIndex = 0; intCharIndex <= strDecimals1.length - 1; intCharIndex++) { strInteger1 = strInteger1 + strDecimals1.substr(intCharIndex, 1); strInteger2 = strInteger2 + strDecimals2.substr(intCharIndex, 1); }
        var intInteger1 = Number(strInteger1); var intInteger2 = Number(strInteger2); var intResult; if (bAddSubtract) { intResult = intInteger1 + intInteger2; } else { intResult = intInteger1 - intInteger2; }
        strResult = intResult.toString(); for (var intZerosAdded = 0; intZerosAdded < ((intOriginalDecimalLength - strResult.length) + 1) ; intZerosAdded++) { strResult = "0" + strResult; }
        if (strResult.length >= intOriginalDecimalLength) { strResult = strResult.substring(0, strResult.length - intOriginalDecimalLength) + "." + strResult.substring(strResult.length - intOriginalDecimalLength); }
    } else { if (bAddSubtract) { strResult = Number(fltValue1) + Number(fltValue2); } else { strResult = Number(fltValue1) - Number(fltValue2); } }
    return Number(strResult);
}
(function (jQuery) {
    jQuery.fn.jStepper = function (options) {
        var opts = jQuery.extend({}, jQuery.fn.jStepper.defaults, options); return this.each(function () {
            var $this = jQuery(this); var o = jQuery.meta ? jQuery.extend({}, opts, $this.data()) : opts; if (o.disableAutocomplete) { $this.attr("autocomplete", "off"); }
            if (jQuery.isFunction($this.mousewheel)) {
                $this.mousewheel(function (objEvent, intDelta) {
                    if (intDelta > 0) { MakeStep(o, 1, objEvent, this); return false; }
                    else if (intDelta < 0) { MakeStep(o, 0, objEvent, this); return false; }
                });
            }
            $this.keydown(function (e) {
                var key = e.keyCode; if (key == 38) { MakeStep(o, 1, e, this); }
                if (key == 40) { MakeStep(o, 0, e, this); }
            }); $this.keyup(function (e) { CheckValue(o, this); });
        });
    }; function CheckValue(o, objElm) {
        var $objElm = jQuery(objElm); var strValue = $objElm.val(); if (o.disableNonNumeric) { strValue = strValue.replace(/[^\d\.,\-]/gi, ""); }
        if (o.maxValue !== null) { if (strValue >= o.maxValue) { strValue = o.maxValue; } }
        if (o.minValue !== null) { if (strValue <= o.minValue && strValue != "") { strValue = o.minValue; } }
        $objElm.val(strValue);
    }
    function MakeStep(o, bDirection, keydown, objElm) {
        var $objElm = jQuery(objElm); var stepToUse; if (keydown) { if (keydown.ctrlKey) { stepToUse = o.ctrlStep; } else if (keydown.shiftKey) { stepToUse = o.shiftStep; } else { stepToUse = o.normalStep; } } else { stepToUse = o.normalStep; }
        var numValue = $objElm.val(); var intSelectionStart = numValue.length - objElm.selectionStart; var intSelectionEnd = numValue.length - objElm.selectionEnd; numValue = numValue.replace(/,/g, "."); numValue = numValue.replace(o.decimalSeparator, "."); numValue = numValue + ''; if (numValue.indexOf(".") != -1) { numValue = numValue.match(new RegExp("-{0,1}[0-9]+[\\.][0-9]*")); }
        numValue = numValue + ''; if (numValue.indexOf("-") != -1) { numValue = numValue.match(new RegExp("-{0,1}[0-9]+[\\.]*[0-9]*")); }
        numValue = numValue + ''; numValue = numValue.match(new RegExp("-{0,1}[0-9]+[\\.]*[0-9]*")); if (numValue === "" || numValue == "-" || numValue === null) { numValue = o.defaultValue; }
        if (bDirection == 1) { numValue = AddOrSubtractTwoFloats(numValue, stepToUse, true); } else { numValue = AddOrSubtractTwoFloats(numValue, stepToUse, false); }
        var bLimitReached = false; if (o.maxValue !== null) { if (numValue >= o.maxValue) { numValue = o.maxValue; bLimitReached = true; } }
        if (o.minValue !== null) { if (numValue <= o.minValue) { numValue = o.minValue; bLimitReached = true; } }
        numValue = numValue + ''; if (o.minLength !== null) {
            var intLengthNow = numValue.length; if (numValue.indexOf(".") != -1) { intLengthNow = numValue.indexOf("."); }
            var bIsNegative = false; if (numValue.indexOf("-") != -1) { bIsNegative = true; numValue = numValue.replace(/-/, ""); }
            if (intLengthNow < o.minLength) { for (var i = 1; i <= (o.minLength - intLengthNow) ; i++) { numValue = '0' + numValue; } }
            if (bIsNegative) { numValue = '-' + numValue; }
        }
        numValue = numValue + ''; var intDecimalsNow; if (o.minDecimals > 0) {
            var intDecimalsMissing; if (numValue.indexOf(".") != -1) { intDecimalsNow = numValue.length - (numValue.indexOf(".") + 1); if (intDecimalsNow < o.minDecimals) { intDecimalsMissing = o.minDecimals - intDecimalsNow; } } else { intDecimalsMissing = o.minDecimals; numValue = numValue + '.'; }
            for (var intDecimalIndex = 1; intDecimalIndex <= intDecimalsMissing; intDecimalIndex++) { numValue = numValue + '0'; }
        }
        if (o.maxDecimals > 0) { intDecimalsNow = 0; if (numValue.indexOf(".") != -1) { intDecimalsNow = numValue.length - (numValue.indexOf(".") + 1); if (o.maxDecimals < intDecimalsNow) { numValue = numValue.substring(0, numValue.indexOf(".")) + "." + numValue.substring(numValue.indexOf(".") + 1, numValue.indexOf(".") + 1 + o.maxDecimals); } } }
        if (!o.allowDecimals) { numValue = numValue + ''; numValue = numValue.replace(new RegExp("[\\.].+"), ""); }
        numValue = numValue.replace(/\./, o.decimalSeparator); $objElm.val(numValue); objElm.selectionStart = numValue.length - intSelectionStart; objElm.selectionEnd = numValue.length - intSelectionEnd; CheckValue(o, objElm); if (o.onStep) { o.onStep($objElm, bDirection, bLimitReached); }
        return false;
    }
    jQuery.fn.jStepper.defaults = { maxValue: null, minValue: null, normalStep: 1, shiftStep: 5, ctrlStep: 10, minLength: null, disableAutocomplete: true, defaultValue: 1, decimalSeparator: ",", allowDecimals: true, minDecimals: 0, maxDecimals: null, disableNonNumeric: true, onStep: null };
})(jQuery);

$(document).ready(function () {

    // The close image will remove it's parent box from the document
    $('.close').click(function () {
        $(this).parent('.alert-message').remove();
    });

    $(".table-sort").tablesorter({ sortList: [[0, 0]] });

});

(function ($) {
    $.isBlank = function (obj) {
        return (!obj || $.trim(obj) === "");
    };
})(jQuery);

(function ($) { $.ui.timepicker = $.ui.timepicker || {}; if ($.ui.timepicker.version) { return } $.extend($.ui, { timepicker: { version: "1.1.1" } }); function Timepicker() { this.regional = []; this.regional[""] = { currentText: "Now", closeText: "Done", amNames: ["AM", "A"], pmNames: ["PM", "P"], timeFormat: "HH:mm", timeSuffix: "", timeOnlyTitle: "Choose Time", timeText: "Time", hourText: "Hour", minuteText: "Minute", secondText: "Second", millisecText: "Millisecond", timezoneText: "Time Zone", isRTL: false }; this._defaults = { showButtonPanel: true, timeOnly: false, showHour: true, showMinute: true, showSecond: false, showMillisec: false, showTimezone: false, showTime: true, stepHour: 1, stepMinute: 1, stepSecond: 1, stepMillisec: 1, hour: 0, minute: 0, second: 0, millisec: 0, timezone: null, useLocalTimezone: false, defaultTimezone: "+0000", hourMin: 0, minuteMin: 0, secondMin: 0, millisecMin: 0, hourMax: 23, minuteMax: 59, secondMax: 59, millisecMax: 999, minDateTime: null, maxDateTime: null, onSelect: null, hourGrid: 0, minuteGrid: 0, secondGrid: 0, millisecGrid: 0, alwaysSetTime: true, separator: " ", altFieldTimeOnly: true, altTimeFormat: null, altSeparator: null, altTimeSuffix: null, pickerTimeFormat: null, pickerTimeSuffix: null, showTimepicker: true, timezoneIso8601: false, timezoneList: null, addSliderAccess: false, sliderAccessArgs: null, controlType: "slider", defaultValue: null, parse: "strict" }; $.extend(this._defaults, this.regional[""]) } $.extend(Timepicker.prototype, { $input: null, $altInput: null, $timeObj: null, inst: null, hour_slider: null, minute_slider: null, second_slider: null, millisec_slider: null, timezone_select: null, hour: 0, minute: 0, second: 0, millisec: 0, timezone: null, defaultTimezone: "+0000", hourMinOriginal: null, minuteMinOriginal: null, secondMinOriginal: null, millisecMinOriginal: null, hourMaxOriginal: null, minuteMaxOriginal: null, secondMaxOriginal: null, millisecMaxOriginal: null, ampm: "", formattedDate: "", formattedTime: "", formattedDateTime: "", timezoneList: null, units: ["hour", "minute", "second", "millisec"], control: null, setDefaults: function (settings) { extendRemove(this._defaults, settings || {}); return this }, _newInst: function ($input, o) { var tp_inst = new Timepicker(), inlineSettings = {}, fns = {}, overrides, i; for (var attrName in this._defaults) { if (this._defaults.hasOwnProperty(attrName)) { var attrValue = $input.attr("time:" + attrName); if (attrValue) { try { inlineSettings[attrName] = eval(attrValue) } catch (err) { inlineSettings[attrName] = attrValue } } } } overrides = { beforeShow: function (input, dp_inst) { if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) { return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst) } }, onChangeMonthYear: function (year, month, dp_inst) { tp_inst._updateDateTime(dp_inst); if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) { tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst) } }, onClose: function (dateText, dp_inst) { if (tp_inst.timeDefined === true && $input.val() !== "") { tp_inst._updateDateTime(dp_inst) } if ($.isFunction(tp_inst._defaults.evnts.onClose)) { tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst) } } }; for (i in overrides) { if (overrides.hasOwnProperty(i)) { fns[i] = o[i] || null } } tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, o, overrides, { evnts: fns, timepicker: tp_inst }); tp_inst.amNames = $.map(tp_inst._defaults.amNames, function (val) { return val.toUpperCase() }); tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function (val) { return val.toUpperCase() }); if (typeof (tp_inst._defaults.controlType) === "string") { if ($.fn[tp_inst._defaults.controlType] === undefined) { tp_inst._defaults.controlType = "select" } tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType] } else { tp_inst.control = tp_inst._defaults.controlType } if (tp_inst._defaults.timezoneList === null) { var timezoneList = ["-1200", "-1100", "-1000", "-0930", "-0900", "-0800", "-0700", "-0600", "-0500", "-0430", "-0400", "-0330", "-0300", "-0200", "-0100", "+0000", "+0100", "+0200", "+0300", "+0330", "+0400", "+0430", "+0500", "+0530", "+0545", "+0600", "+0630", "+0700", "+0800", "+0845", "+0900", "+0930", "+1000", "+1030", "+1100", "+1130", "+1200", "+1245", "+1300", "+1400"]; if (tp_inst._defaults.timezoneIso8601) { timezoneList = $.map(timezoneList, function (val) { return val == "+0000" ? "Z" : (val.substring(0, 3) + ":" + val.substring(3)) }) } tp_inst._defaults.timezoneList = timezoneList } tp_inst.timezone = tp_inst._defaults.timezone; tp_inst.hour = tp_inst._defaults.hour; tp_inst.minute = tp_inst._defaults.minute; tp_inst.second = tp_inst._defaults.second; tp_inst.millisec = tp_inst._defaults.millisec; tp_inst.ampm = ""; tp_inst.$input = $input; if (o.altField) { tp_inst.$altInput = $(o.altField).css({ cursor: "pointer" }).focus(function () { $input.trigger("focus") }) } if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) { tp_inst._defaults.minDate = new Date() } if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) { tp_inst._defaults.maxDate = new Date() } if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) { tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime()) } if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) { tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime()) } if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) { tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime()) } if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) { tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime()) } tp_inst.$input.bind("focus", function () { tp_inst._onFocus() }); return tp_inst }, _addTimePicker: function (dp_inst) { var currDT = (this.$altInput && this._defaults.altFieldTimeOnly) ? this.$input.val() + " " + this.$altInput.val() : this.$input.val(); this.timeDefined = this._parseTime(currDT); this._limitMinMaxDateTime(dp_inst, false); this._injectTimePicker() }, _parseTime: function (timeString, withDate) { if (!this.inst) { this.inst = $.datepicker._getInst(this.$input[0]) } if (withDate || !this._defaults.timeOnly) { var dp_dateFormat = $.datepicker._get(this.inst, "dateFormat"); try { var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults); if (!parseRes.timeObj) { return false } $.extend(this, parseRes.timeObj) } catch (err) { $.datepicker.log("Error parsing the date/time string: " + err + "\ndate/time string = " + timeString + "\ntimeFormat = " + this._defaults.timeFormat + "\ndateFormat = " + dp_dateFormat); return false } return true } else { var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults); if (!timeObj) { return false } $.extend(this, timeObj); return true } }, _injectTimePicker: function () { var $dp = this.inst.dpDiv, o = this.inst.settings, tp_inst = this, litem = "", uitem = "", max = {}, gridSize = {}, size = null; if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) { var noDisplay = ' style="display:none;"', html = '<div class="ui-timepicker-div' + (o.isRTL ? " ui-timepicker-rtl" : "") + '"><dl><dt class="ui_tpicker_time_label"' + ((o.showTime) ? "" : noDisplay) + ">" + o.timeText + '</dt><dd class="ui_tpicker_time"' + ((o.showTime) ? "" : noDisplay) + "></dd>"; for (var i = 0, l = this.units.length; i < l; i++) { litem = this.units[i]; uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1); max[litem] = parseInt((o[litem + "Max"] - ((o[litem + "Max"] - o[litem + "Min"]) % o["step" + uitem])), 10); gridSize[litem] = 0; html += '<dt class="ui_tpicker_' + litem + '_label"' + ((o["show" + uitem]) ? "" : noDisplay) + ">" + o[litem + "Text"] + '</dt><dd class="ui_tpicker_' + litem + '"><div class="ui_tpicker_' + litem + '_slider"' + ((o["show" + uitem]) ? "" : noDisplay) + "></div>"; if (o["show" + uitem] && o[litem + "Grid"] > 0) { html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>'; if (litem == "hour") { for (var h = o[litem + "Min"]; h <= max[litem]; h += parseInt(o[litem + "Grid"], 10)) { gridSize[litem]++; var tmph = $.datepicker.formatTime(useAmpm(o.pickerTimeFormat || o.timeFormat) ? "hht" : "HH", { hour: h }, o); html += '<td data-for="' + litem + '">' + tmph + "</td>" } } else { for (var m = o[litem + "Min"]; m <= max[litem]; m += parseInt(o[litem + "Grid"], 10)) { gridSize[litem]++; html += '<td data-for="' + litem + '">' + ((m < 10) ? "0" : "") + m + "</td>" } } html += "</tr></table></div>" } html += "</dd>" } html += '<dt class="ui_tpicker_timezone_label"' + ((o.showTimezone) ? "" : noDisplay) + ">" + o.timezoneText + "</dt>"; html += '<dd class="ui_tpicker_timezone" ' + ((o.showTimezone) ? "" : noDisplay) + "></dd>"; html += "</dl></div>"; var $tp = $(html); if (o.timeOnly === true) { $tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all"><div class="ui-datepicker-title">' + o.timeOnlyTitle + "</div></div>"); $dp.find(".ui-datepicker-header, .ui-datepicker-calendar").hide() } for (var i = 0, l = tp_inst.units.length; i < l; i++) { litem = tp_inst.units[i]; uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1); tp_inst[litem + "_slider"] = tp_inst.control.create(tp_inst, $tp.find(".ui_tpicker_" + litem + "_slider"), litem, tp_inst[litem], o[litem + "Min"], max[litem], o["step" + uitem]); if (o["show" + uitem] && o[litem + "Grid"] > 0) { size = 100 * gridSize[litem] * o[litem + "Grid"] / (max[litem] - o[litem + "Min"]); $tp.find(".ui_tpicker_" + litem + " table").css({ width: size + "%", marginLeft: o.isRTL ? "0" : ((size / (-2 * gridSize[litem])) + "%"), marginRight: o.isRTL ? ((size / (-2 * gridSize[litem])) + "%") : "0", borderCollapse: "collapse" }).find("td").click(function (e) { var $t = $(this), h = $t.html(), n = parseInt(h.replace(/[^0-9]/g), 10), ap = h.replace(/[^apm]/ig), f = $t.data("for"); if (f == "hour") { if (ap.indexOf("p") !== -1 && n < 12) { n += 12 } else { if (ap.indexOf("a") !== -1 && n === 12) { n = 0 } } } tp_inst.control.value(tp_inst, tp_inst[f + "_slider"], litem, n); tp_inst._onTimeChange(); tp_inst._onSelectHandler() }).css({ cursor: "pointer", width: (100 / gridSize[litem]) + "%", textAlign: "center", overflow: "hidden" }) } } this.timezone_select = $tp.find(".ui_tpicker_timezone").append("<select></select>").find("select"); $.fn.append.apply(this.timezone_select, $.map(o.timezoneList, function (val, idx) { return $("<option />").val(typeof val == "object" ? val.value : val).text(typeof val == "object" ? val.label : val) })); if (typeof (this.timezone) != "undefined" && this.timezone !== null && this.timezone !== "") { var local_date = new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12); var local_timezone = $.timepicker.timeZoneOffsetString(local_date); if (local_timezone == this.timezone) { selectLocalTimeZone(tp_inst) } else { this.timezone_select.val(this.timezone) } } else { if (typeof (this.hour) != "undefined" && this.hour !== null && this.hour !== "") { this.timezone_select.val(o.defaultTimezone) } else { selectLocalTimeZone(tp_inst) } } this.timezone_select.change(function () { tp_inst._defaults.useLocalTimezone = false; tp_inst._onTimeChange() }); var $buttonPanel = $dp.find(".ui-datepicker-buttonpane"); if ($buttonPanel.length) { $buttonPanel.before($tp) } else { $dp.append($tp) } this.$timeObj = $tp.find(".ui_tpicker_time"); if (this.inst !== null) { var timeDefined = this.timeDefined; this._onTimeChange(); this.timeDefined = timeDefined } if (this._defaults.addSliderAccess) { var sliderAccessArgs = this._defaults.sliderAccessArgs, rtl = this._defaults.isRTL; sliderAccessArgs.isRTL = rtl; setTimeout(function () { if ($tp.find(".ui-slider-access").length === 0) { $tp.find(".ui-slider:visible").sliderAccess(sliderAccessArgs); var sliderAccessWidth = $tp.find(".ui-slider-access:eq(0)").outerWidth(true); if (sliderAccessWidth) { $tp.find("table:visible").each(function () { var $g = $(this), oldWidth = $g.outerWidth(), oldMarginLeft = $g.css(rtl ? "marginRight" : "marginLeft").toString().replace("%", ""), newWidth = oldWidth - sliderAccessWidth, newMarginLeft = ((oldMarginLeft * newWidth) / oldWidth) + "%", css = { width: newWidth, marginRight: 0, marginLeft: 0 }; css[rtl ? "marginRight" : "marginLeft"] = newMarginLeft; $g.css(css) }) } } }, 10) } } }, _limitMinMaxDateTime: function (dp_inst, adjustSliders) { var o = this._defaults, dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay); if (!this._defaults.showTimepicker) { return } if ($.datepicker._get(dp_inst, "minDateTime") !== null && $.datepicker._get(dp_inst, "minDateTime") !== undefined && dp_date) { var minDateTime = $.datepicker._get(dp_inst, "minDateTime"), minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0); if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null) { this.hourMinOriginal = o.hourMin; this.minuteMinOriginal = o.minuteMin; this.secondMinOriginal = o.secondMin; this.millisecMinOriginal = o.millisecMin } if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() == dp_date.getTime()) { this._defaults.hourMin = minDateTime.getHours(); if (this.hour <= this._defaults.hourMin) { this.hour = this._defaults.hourMin; this._defaults.minuteMin = minDateTime.getMinutes(); if (this.minute <= this._defaults.minuteMin) { this.minute = this._defaults.minuteMin; this._defaults.secondMin = minDateTime.getSeconds(); if (this.second <= this._defaults.secondMin) { this.second = this._defaults.secondMin; this._defaults.millisecMin = minDateTime.getMilliseconds() } else { if (this.millisec < this._defaults.millisecMin) { this.millisec = this._defaults.millisecMin } this._defaults.millisecMin = this.millisecMinOriginal } } else { this._defaults.secondMin = this.secondMinOriginal; this._defaults.millisecMin = this.millisecMinOriginal } } else { this._defaults.minuteMin = this.minuteMinOriginal; this._defaults.secondMin = this.secondMinOriginal; this._defaults.millisecMin = this.millisecMinOriginal } } else { this._defaults.hourMin = this.hourMinOriginal; this._defaults.minuteMin = this.minuteMinOriginal; this._defaults.secondMin = this.secondMinOriginal; this._defaults.millisecMin = this.millisecMinOriginal } } if ($.datepicker._get(dp_inst, "maxDateTime") !== null && $.datepicker._get(dp_inst, "maxDateTime") !== undefined && dp_date) { var maxDateTime = $.datepicker._get(dp_inst, "maxDateTime"), maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0); if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null) { this.hourMaxOriginal = o.hourMax; this.minuteMaxOriginal = o.minuteMax; this.secondMaxOriginal = o.secondMax; this.millisecMaxOriginal = o.millisecMax } if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() == dp_date.getTime()) { this._defaults.hourMax = maxDateTime.getHours(); if (this.hour >= this._defaults.hourMax) { this.hour = this._defaults.hourMax; this._defaults.minuteMax = maxDateTime.getMinutes(); if (this.minute >= this._defaults.minuteMax) { this.minute = this._defaults.minuteMax; this._defaults.secondMax = maxDateTime.getSeconds() } else { if (this.second >= this._defaults.secondMax) { this.second = this._defaults.secondMax; this._defaults.millisecMax = maxDateTime.getMilliseconds() } else { if (this.millisec > this._defaults.millisecMax) { this.millisec = this._defaults.millisecMax } this._defaults.millisecMax = this.millisecMaxOriginal } } } else { this._defaults.minuteMax = this.minuteMaxOriginal; this._defaults.secondMax = this.secondMaxOriginal; this._defaults.millisecMax = this.millisecMaxOriginal } } else { this._defaults.hourMax = this.hourMaxOriginal; this._defaults.minuteMax = this.minuteMaxOriginal; this._defaults.secondMax = this.secondMaxOriginal; this._defaults.millisecMax = this.millisecMaxOriginal } } if (adjustSliders !== undefined && adjustSliders === true) { var hourMax = parseInt((this._defaults.hourMax - ((this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour)), 10), minMax = parseInt((this._defaults.minuteMax - ((this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute)), 10), secMax = parseInt((this._defaults.secondMax - ((this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond)), 10), millisecMax = parseInt((this._defaults.millisecMax - ((this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec)), 10); if (this.hour_slider) { this.control.options(this, this.hour_slider, "hour", { min: this._defaults.hourMin, max: hourMax }); this.control.value(this, this.hour_slider, "hour", this.hour) } if (this.minute_slider) { this.control.options(this, this.minute_slider, "minute", { min: this._defaults.minuteMin, max: minMax }); this.control.value(this, this.minute_slider, "minute", this.minute) } if (this.second_slider) { this.control.options(this, this.second_slider, "second", { min: this._defaults.secondMin, max: secMax }); this.control.value(this, this.second_slider, "second", this.second) } if (this.millisec_slider) { this.control.options(this, this.millisec_slider, "millisec", { min: this._defaults.millisecMin, max: millisecMax }); this.control.value(this, this.millisec_slider, "millisec", this.millisec) } } }, _onTimeChange: function () { var hour = (this.hour_slider) ? this.control.value(this, this.hour_slider, "hour") : false, minute = (this.minute_slider) ? this.control.value(this, this.minute_slider, "minute") : false, second = (this.second_slider) ? this.control.value(this, this.second_slider, "second") : false, millisec = (this.millisec_slider) ? this.control.value(this, this.millisec_slider, "millisec") : false, timezone = (this.timezone_select) ? this.timezone_select.val() : false, o = this._defaults, pickerTimeFormat = o.pickerTimeFormat || o.timeFormat, pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix; if (typeof (hour) == "object") { hour = false } if (typeof (minute) == "object") { minute = false } if (typeof (second) == "object") { second = false } if (typeof (millisec) == "object") { millisec = false } if (typeof (timezone) == "object") { timezone = false } if (hour !== false) { hour = parseInt(hour, 10) } if (minute !== false) { minute = parseInt(minute, 10) } if (second !== false) { second = parseInt(second, 10) } if (millisec !== false) { millisec = parseInt(millisec, 10) } var ampm = o[hour < 12 ? "amNames" : "pmNames"][0]; var hasChanged = (hour != this.hour || minute != this.minute || second != this.second || millisec != this.millisec || (this.ampm.length > 0 && (hour < 12) != ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1)) || ((this.timezone === null && timezone != this.defaultTimezone) || (this.timezone !== null && timezone != this.timezone))); if (hasChanged) { if (hour !== false) { this.hour = hour } if (minute !== false) { this.minute = minute } if (second !== false) { this.second = second } if (millisec !== false) { this.millisec = millisec } if (timezone !== false) { this.timezone = timezone } if (!this.inst) { this.inst = $.datepicker._getInst(this.$input[0]) } this._limitMinMaxDateTime(this.inst, true) } if (useAmpm(o.timeFormat)) { this.ampm = ampm } this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o); if (this.$timeObj) { if (pickerTimeFormat === o.timeFormat) { this.$timeObj.text(this.formattedTime + pickerTimeSuffix) } else { this.$timeObj.text($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix) } } this.timeDefined = true; if (hasChanged) { this._updateDateTime() } }, _onSelectHandler: function () { var onSelect = this._defaults.onSelect || this.inst.settings.onSelect; var inputEl = this.$input ? this.$input[0] : null; if (onSelect && inputEl) { onSelect.apply(inputEl, [this.formattedDateTime, this]) } }, _updateDateTime: function (dp_inst) { dp_inst = this.inst || dp_inst; var dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)), dateFmt = $.datepicker._get(dp_inst, "dateFormat"), formatCfg = $.datepicker._getFormatConfig(dp_inst), timeAvailable = dt !== null && this.timeDefined; this.formattedDate = $.datepicker.formatDate(dateFmt, (dt === null ? new Date() : dt), formatCfg); var formattedDateTime = this.formattedDate; if (this._defaults.timeOnly === true) { formattedDateTime = this.formattedTime } else { if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable)) { formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix } } this.formattedDateTime = formattedDateTime; if (!this._defaults.showTimepicker) { this.$input.val(this.formattedDate) } else { if (this.$altInput && this._defaults.altFieldTimeOnly === true) { this.$altInput.val(this.formattedTime); this.$input.val(this.formattedDate) } else { if (this.$altInput) { this.$input.val(formattedDateTime); var altFormattedDateTime = "", altSeparator = this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator, altTimeSuffix = this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix; if (this._defaults.altFormat) { altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, (dt === null ? new Date() : dt), formatCfg) } else { altFormattedDateTime = this.formattedDate } if (altFormattedDateTime) { altFormattedDateTime += altSeparator } if (this._defaults.altTimeFormat) { altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix } else { altFormattedDateTime += this.formattedTime + altTimeSuffix } this.$altInput.val(altFormattedDateTime) } else { this.$input.val(formattedDateTime) } } } this.$input.trigger("change") }, _onFocus: function () { if (!this.$input.val() && this._defaults.defaultValue) { this.$input.val(this._defaults.defaultValue); var inst = $.datepicker._getInst(this.$input.get(0)), tp_inst = $.datepicker._get(inst, "timepicker"); if (tp_inst) { if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) { try { $.datepicker._updateDatepicker(inst) } catch (err) { $.datepicker.log(err) } } } } }, _controls: { slider: { create: function (tp_inst, obj, unit, val, min, max, step) { var rtl = tp_inst._defaults.isRTL; return obj.prop("slide", null).slider({ orientation: "horizontal", value: rtl ? val * -1 : val, min: rtl ? max * -1 : min, max: rtl ? min * -1 : max, step: step, slide: function (event, ui) { tp_inst.control.value(tp_inst, $(this), unit, rtl ? ui.value * -1 : ui.value); tp_inst._onTimeChange() }, stop: function (event, ui) { tp_inst._onSelectHandler() } }) }, options: function (tp_inst, obj, unit, opts, val) { if (tp_inst._defaults.isRTL) { if (typeof (opts) == "string") { if (opts == "min" || opts == "max") { if (val !== undefined) { return obj.slider(opts, val * -1) } return Math.abs(obj.slider(opts)) } return obj.slider(opts) } var min = opts.min, max = opts.max; opts.min = opts.max = null; if (min !== undefined) { opts.max = min * -1 } if (max !== undefined) { opts.min = max * -1 } return obj.slider(opts) } if (typeof (opts) == "string" && val !== undefined) { return obj.slider(opts, val) } return obj.slider(opts) }, value: function (tp_inst, obj, unit, val) { if (tp_inst._defaults.isRTL) { if (val !== undefined) { return obj.slider("value", val * -1) } return Math.abs(obj.slider("value")) } if (val !== undefined) { return obj.slider("value", val) } return obj.slider("value") } }, select: { create: function (tp_inst, obj, unit, val, min, max, step) { var sel = '<select class="ui-timepicker-select" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">', ul = tp_inst._defaults.timeFormat.indexOf("t") !== -1 ? "toLowerCase" : "toUpperCase", m = 0; for (var i = min; i <= max; i += step) { sel += '<option value="' + i + '"' + (i == val ? " selected" : "") + ">"; if (unit == "hour" && useAmpm(tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat)) { sel += $.datepicker.formatTime("hh TT", { hour: i }, tp_inst._defaults) } else { if (unit == "millisec" || i >= 10) { sel += i } else { sel += "0" + i.toString() } } sel += "</option>" } sel += "</select>"; obj.children("select").remove(); $(sel).appendTo(obj).change(function (e) { tp_inst._onTimeChange(); tp_inst._onSelectHandler() }); return obj }, options: function (tp_inst, obj, unit, opts, val) { var o = {}, $t = obj.children("select"); if (typeof (opts) == "string") { if (val === undefined) { return $t.data(opts) } o[opts] = val } else { o = opts } return tp_inst.control.create(tp_inst, obj, $t.data("unit"), $t.val(), o.min || $t.data("min"), o.max || $t.data("max"), o.step || $t.data("step")) }, value: function (tp_inst, obj, unit, val) { var $t = obj.children("select"); if (val !== undefined) { return $t.val(val) } return $t.val() } } } }); $.fn.extend({ timepicker: function (o) { o = o || {}; var tmp_args = Array.prototype.slice.call(arguments); if (typeof o == "object") { tmp_args[0] = $.extend(o, { timeOnly: true }) } return $(this).each(function () { $.fn.datetimepicker.apply($(this), tmp_args) }) }, datetimepicker: function (o) { o = o || {}; var tmp_args = arguments; if (typeof (o) == "string") { if (o == "getDate") { return $.fn.datepicker.apply($(this[0]), tmp_args) } else { return this.each(function () { var $t = $(this); $t.datepicker.apply($t, tmp_args) }) } } else { return this.each(function () { var $t = $(this); $t.datepicker($.timepicker._newInst($t, o)._defaults) }) } } }); $.datepicker.parseDateTime = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) { var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings); if (parseRes.timeObj) { var t = parseRes.timeObj; parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec) } return parseRes.date }; $.datepicker.parseTime = function (timeFormat, timeString, options) { var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}); var strictParse = function (f, s, o) { var getPatternAmpm = function (amNames, pmNames) { var markers = []; if (amNames) { $.merge(markers, amNames) } if (pmNames) { $.merge(markers, pmNames) } markers = $.map(markers, function (val) { return val.replace(/[.*+?|()\[\]{}\\]/g, "\\$&") }); return "(" + markers.join("|") + ")?" }; var getFormatPositions = function (timeFormat) { var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|t{1,2}|z|'.*?')/g), orders = { h: -1, m: -1, s: -1, l: -1, t: -1, z: -1 }; if (finds) { for (var i = 0; i < finds.length; i++) { if (orders[finds[i].toString().charAt(0)] == -1) { orders[finds[i].toString().charAt(0)] = i + 1 } } } return orders }; var regstr = "^" + f.toString().replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[lz]|'.*?')/g, function (match) { switch (match.charAt(0).toLowerCase()) { case "h": return "(\\d?\\d)"; case "m": return "(\\d?\\d)"; case "s": return "(\\d?\\d)"; case "l": return "(\\d?\\d?\\d)"; case "z": return "(z|[-+]\\d\\d:?\\d\\d|\\S+)?"; case "t": return getPatternAmpm(o.amNames, o.pmNames); default: return "(" + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) { return "\\" + m }) + ")?" } }).replace(/\s/g, "\\s?") + o.timeSuffix + "$", order = getFormatPositions(f), ampm = "", treg; treg = s.match(new RegExp(regstr, "i")); var resTime = { hour: 0, minute: 0, second: 0, millisec: 0 }; if (treg) { if (order.t !== -1) { if (treg[order.t] === undefined || treg[order.t].length === 0) { ampm = ""; resTime.ampm = "" } else { ampm = $.inArray(treg[order.t].toUpperCase(), o.amNames) !== -1 ? "AM" : "PM"; resTime.ampm = o[ampm == "AM" ? "amNames" : "pmNames"][0] } } if (order.h !== -1) { if (ampm == "AM" && treg[order.h] == "12") { resTime.hour = 0 } else { if (ampm == "PM" && treg[order.h] != "12") { resTime.hour = parseInt(treg[order.h], 10) + 12 } else { resTime.hour = Number(treg[order.h]) } } } if (order.m !== -1) { resTime.minute = Number(treg[order.m]) } if (order.s !== -1) { resTime.second = Number(treg[order.s]) } if (order.l !== -1) { resTime.millisec = Number(treg[order.l]) } if (order.z !== -1 && treg[order.z] !== undefined) { var tz = treg[order.z].toUpperCase(); switch (tz.length) { case 1: tz = o.timezoneIso8601 ? "Z" : "+0000"; break; case 5: if (o.timezoneIso8601) { tz = tz.substring(1) == "0000" ? "Z" : tz.substring(0, 3) + ":" + tz.substring(3) } break; case 6: if (!o.timezoneIso8601) { tz = tz == "Z" || tz.substring(1) == "00:00" ? "+0000" : tz.replace(/:/, "") } else { if (tz.substring(1) == "00:00") { tz = "Z" } } break } resTime.timezone = tz } return resTime } return false }; var looseParse = function (f, s, o) { try { var d = new Date("2012-01-01 " + s); return { hour: d.getHours(), minutes: d.getMinutes(), seconds: d.getSeconds(), millisec: d.getMilliseconds(), timezone: $.timepicker.timeZoneOffsetString(d) } } catch (err) { try { return strictParse(f, s, o) } catch (err2) { $.datepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f) } } return false }; if (typeof o.parse === "function") { return o.parse(timeFormat, timeString, o) } if (o.parse === "loose") { return looseParse(timeFormat, timeString, o) } return strictParse(timeFormat, timeString, o) }; $.datepicker.formatTime = function (format, time, options) { options = options || {}; options = $.extend({}, $.timepicker._defaults, options); time = $.extend({ hour: 0, minute: 0, second: 0, millisec: 0, timezone: "+0000" }, time); var tmptime = format, ampmName = options.amNames[0], hour = parseInt(time.hour, 10); if (hour > 11) { ampmName = options.pmNames[0] } tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[lz]|('.*?'|".*?"))/g, function (match) { switch (match) { case "HH": return ("0" + hour).slice(-2); case "H": return hour; case "hh": return ("0" + convert24to12(hour)).slice(-2); case "h": return convert24to12(hour); case "mm": return ("0" + time.minute).slice(-2); case "m": return time.minute; case "ss": return ("0" + time.second).slice(-2); case "s": return time.second; case "l": return ("00" + time.millisec).slice(-3); case "z": return time.timezone === null ? options.defaultTimezone : time.timezone; case "T": return ampmName.charAt(0).toUpperCase(); case "TT": return ampmName.toUpperCase(); case "t": return ampmName.charAt(0).toLowerCase(); case "tt": return ampmName.toLowerCase(); default: return match.replace(/\'/g, "") || "'" } }); tmptime = $.trim(tmptime); return tmptime }; $.datepicker._base_selectDate = $.datepicker._selectDate; $.datepicker._selectDate = function (id, dateStr) { var inst = this._getInst($(id)[0]), tp_inst = this._get(inst, "timepicker"); if (tp_inst) { tp_inst._limitMinMaxDateTime(inst, true); inst.inline = inst.stay_open = true; this._base_selectDate(id, dateStr); inst.inline = inst.stay_open = false; this._notifyChange(inst); this._updateDatepicker(inst) } else { this._base_selectDate(id, dateStr) } }; $.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker; $.datepicker._updateDatepicker = function (inst) { var input = inst.input[0]; if ($.datepicker._curInst && $.datepicker._curInst != inst && $.datepicker._datepickerShowing && $.datepicker._lastInput != input) { return } if (typeof (inst.stay_open) !== "boolean" || inst.stay_open === false) { this._base_updateDatepicker(inst); var tp_inst = this._get(inst, "timepicker"); if (tp_inst) { tp_inst._addTimePicker(inst); if (tp_inst._defaults.useLocalTimezone) { var date = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay, 12); selectLocalTimeZone(tp_inst, date); tp_inst._onTimeChange() } } } }; $.datepicker._base_doKeyPress = $.datepicker._doKeyPress; $.datepicker._doKeyPress = function (event) { var inst = $.datepicker._getInst(event.target), tp_inst = $.datepicker._get(inst, "timepicker"); if (tp_inst) { if ($.datepicker._get(inst, "constrainInput")) { var ampm = useAmpm(tp_inst._defaults.timeFormat), dateChars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat")), datetimeChars = tp_inst._defaults.timeFormat.toString().replace(/[hms]/g, "").replace(/TT/g, ampm ? "APM" : "").replace(/Tt/g, ampm ? "AaPpMm" : "").replace(/tT/g, ampm ? "AaPpMm" : "").replace(/T/g, ampm ? "AP" : "").replace(/tt/g, ampm ? "apm" : "").replace(/t/g, ampm ? "ap" : "") + " " + tp_inst._defaults.separator + tp_inst._defaults.timeSuffix + (tp_inst._defaults.showTimezone ? tp_inst._defaults.timezoneList.join("") : "") + (tp_inst._defaults.amNames.join("")) + (tp_inst._defaults.pmNames.join("")) + dateChars, chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode); return event.ctrlKey || (chr < " " || !dateChars || datetimeChars.indexOf(chr) > -1) } } return $.datepicker._base_doKeyPress(event) }; $.datepicker._base_updateAlternate = $.datepicker._updateAlternate; $.datepicker._updateAlternate = function (inst) { var tp_inst = this._get(inst, "timepicker"); if (tp_inst) { var altField = tp_inst._defaults.altField; if (altField) { var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat, date = this._getDate(inst), formatCfg = $.datepicker._getFormatConfig(inst), altFormattedDateTime = "", altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator, altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix, altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat; altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix; if (!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly) { if (tp_inst._defaults.altFormat) { altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, (date === null ? new Date() : date), formatCfg) + altSeparator + altFormattedDateTime } else { altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime } } $(altField).val(altFormattedDateTime) } } else { $.datepicker._base_updateAlternate(inst) } }; $.datepicker._base_doKeyUp = $.datepicker._doKeyUp; $.datepicker._doKeyUp = function (event) { var inst = $.datepicker._getInst(event.target), tp_inst = $.datepicker._get(inst, "timepicker"); if (tp_inst) { if (tp_inst._defaults.timeOnly && (inst.input.val() != inst.lastVal)) { try { $.datepicker._updateDatepicker(inst) } catch (err) { $.datepicker.log(err) } } } return $.datepicker._base_doKeyUp(event) }; $.datepicker._base_gotoToday = $.datepicker._gotoToday; $.datepicker._gotoToday = function (id) { var inst = this._getInst($(id)[0]), $dp = inst.dpDiv; this._base_gotoToday(id); var tp_inst = this._get(inst, "timepicker"); selectLocalTimeZone(tp_inst); var now = new Date(); this._setTime(inst, now); $(".ui-datepicker-today", $dp).click() }; $.datepicker._disableTimepickerDatepicker = function (target) { var inst = this._getInst(target); if (!inst) { return } var tp_inst = this._get(inst, "timepicker"); $(target).datepicker("getDate"); if (tp_inst) { tp_inst._defaults.showTimepicker = false; tp_inst._updateDateTime(inst) } }; $.datepicker._enableTimepickerDatepicker = function (target) { var inst = this._getInst(target); if (!inst) { return } var tp_inst = this._get(inst, "timepicker"); $(target).datepicker("getDate"); if (tp_inst) { tp_inst._defaults.showTimepicker = true; tp_inst._addTimePicker(inst); tp_inst._updateDateTime(inst) } }; $.datepicker._setTime = function (inst, date) { var tp_inst = this._get(inst, "timepicker"); if (tp_inst) { var defaults = tp_inst._defaults; tp_inst.hour = date ? date.getHours() : defaults.hour; tp_inst.minute = date ? date.getMinutes() : defaults.minute; tp_inst.second = date ? date.getSeconds() : defaults.second; tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec; tp_inst._limitMinMaxDateTime(inst, true); tp_inst._onTimeChange(); tp_inst._updateDateTime(inst) } }; $.datepicker._setTimeDatepicker = function (target, date, withDate) { var inst = this._getInst(target); if (!inst) { return } var tp_inst = this._get(inst, "timepicker"); if (tp_inst) { this._setDateFromField(inst); var tp_date; if (date) { if (typeof date == "string") { tp_inst._parseTime(date, withDate); tp_date = new Date(); tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec) } else { tp_date = new Date(date.getTime()) } if (tp_date.toString() == "Invalid Date") { tp_date = undefined } this._setTime(inst, tp_date) } } }; $.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker; $.datepicker._setDateDatepicker = function (target, date) { var inst = this._getInst(target); if (!inst) { return } var tp_date = (date instanceof Date) ? new Date(date.getTime()) : date; this._updateDatepicker(inst); this._base_setDateDatepicker.apply(this, arguments); this._setTimeDatepicker(target, tp_date, true) }; $.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker; $.datepicker._getDateDatepicker = function (target, noDefault) { var inst = this._getInst(target); if (!inst) { return } var tp_inst = this._get(inst, "timepicker"); if (tp_inst) { if (inst.lastVal === undefined) { this._setDateFromField(inst, noDefault) } var date = this._getDate(inst); if (date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly)) { date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec) } return date } return this._base_getDateDatepicker(target, noDefault) }; $.datepicker._base_parseDate = $.datepicker.parseDate; $.datepicker.parseDate = function (format, value, settings) { var date; try { date = this._base_parseDate(format, value, settings) } catch (err) { date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(":") - 2)), settings); $.datepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format) } return date }; $.datepicker._base_formatDate = $.datepicker._formatDate; $.datepicker._formatDate = function (inst, day, month, year) { var tp_inst = this._get(inst, "timepicker"); if (tp_inst) { tp_inst._updateDateTime(inst); return tp_inst.$input.val() } return this._base_formatDate(inst) }; $.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker; $.datepicker._optionDatepicker = function (target, name, value) { var inst = this._getInst(target), name_clone; if (!inst) { return null } var tp_inst = this._get(inst, "timepicker"); if (tp_inst) { var min = null, max = null, onselect = null, overrides = tp_inst._defaults.evnts, fns = {}, prop; if (typeof name == "string") { if (name === "minDate" || name === "minDateTime") { min = value } else { if (name === "maxDate" || name === "maxDateTime") { max = value } else { if (name === "onSelect") { onselect = value } else { if (overrides.hasOwnProperty(name)) { if (typeof (value) === "undefined") { return overrides[name] } fns[name] = value; name_clone = {} } } } } } else { if (typeof name == "object") { if (name.minDate) { min = name.minDate } else { if (name.minDateTime) { min = name.minDateTime } else { if (name.maxDate) { max = name.maxDate } else { if (name.maxDateTime) { max = name.maxDateTime } } } } for (prop in overrides) { if (overrides.hasOwnProperty(prop) && name[prop]) { fns[prop] = name[prop] } } } } for (prop in fns) { if (fns.hasOwnProperty(prop)) { overrides[prop] = fns[prop]; if (!name_clone) { name_clone = $.extend({}, name) } delete name_clone[prop] } } if (name_clone && isEmptyObject(name_clone)) { return } if (min) { if (min === 0) { min = new Date() } else { min = new Date(min) } tp_inst._defaults.minDate = min; tp_inst._defaults.minDateTime = min } else { if (max) { if (max === 0) { max = new Date() } else { max = new Date(max) } tp_inst._defaults.maxDate = max; tp_inst._defaults.maxDateTime = max } else { if (onselect) { tp_inst._defaults.onSelect = onselect } } } } if (value === undefined) { return this._base_optionDatepicker.call($.datepicker, target, name) } return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value) }; var isEmptyObject = function (obj) { var prop; for (prop in obj) { if (obj.hasOwnProperty(obj)) { return false } } return true }; var extendRemove = function (target, props) { $.extend(target, props); for (var name in props) { if (props[name] === null || props[name] === undefined) { target[name] = props[name] } } return target }; var useAmpm = function (timeFormat) { return (timeFormat.indexOf("t") !== -1 && timeFormat.indexOf("h") !== -1) }; var convert24to12 = function (hour) { if (hour > 12) { hour = hour - 12 } if (hour == 0) { hour = 12 } return String(hour) }; var splitDateTime = function (dateFormat, dateTimeString, dateSettings, timeSettings) { try { var separator = timeSettings && timeSettings.separator ? timeSettings.separator : $.timepicker._defaults.separator, format = timeSettings && timeSettings.timeFormat ? timeSettings.timeFormat : $.timepicker._defaults.timeFormat, timeParts = format.split(separator), timePartsLen = timeParts.length, allParts = dateTimeString.split(separator), allPartsLen = allParts.length; if (allPartsLen > 1) { return [allParts.splice(0, allPartsLen - timePartsLen).join(separator), allParts.splice(0, timePartsLen).join(separator)] } } catch (err) { $.datepicker.log("Could not split the date from the time. Please check the following datetimepicker options\nthrown error: " + err + "\ndateTimeString" + dateTimeString + "\ndateFormat = " + dateFormat + "\nseparator = " + timeSettings.separator + "\ntimeFormat = " + timeSettings.timeFormat); if (err.indexOf(":") >= 0) { var dateStringLength = dateTimeString.length - (err.length - err.indexOf(":") - 2), timeString = dateTimeString.substring(dateStringLength); return [$.trim(dateTimeString.substring(0, dateStringLength)), $.trim(dateTimeString.substring(dateStringLength))] } else { throw err } } return [dateTimeString, ""] }; var parseDateTimeInternal = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) { var date; var splitRes = splitDateTime(dateFormat, dateTimeString, dateSettings, timeSettings); date = $.datepicker._base_parseDate(dateFormat, splitRes[0], dateSettings); if (splitRes[1] !== "") { var timeString = splitRes[1], parsedTime = $.datepicker.parseTime(timeFormat, timeString, timeSettings); if (parsedTime === null) { throw "Wrong time format" } return { date: date, timeObj: parsedTime } } else { return { date: date } } }; var selectLocalTimeZone = function (tp_inst, date) { if (tp_inst && tp_inst.timezone_select) { tp_inst._defaults.useLocalTimezone = true; var now = typeof date !== "undefined" ? date : new Date(); var tzoffset = $.timepicker.timeZoneOffsetString(now); if (tp_inst._defaults.timezoneIso8601) { tzoffset = tzoffset.substring(0, 3) + ":" + tzoffset.substring(3) } tp_inst.timezone_select.val(tzoffset) } }; $.timepicker = new Timepicker(); $.timepicker.timeZoneOffsetString = function (date) { var off = date.getTimezoneOffset() * -1, minutes = off % 60, hours = (off - minutes) / 60; return (off >= 0 ? "+" : "-") + ("0" + (hours * 101).toString()).substr(-2) + ("0" + (minutes * 101).toString()).substr(-2) }; $.timepicker.timeRange = function (startTime, endTime, options) { return $.timepicker.handleRange("timepicker", startTime, endTime, options) }; $.timepicker.dateTimeRange = function (startTime, endTime, options) { $.timepicker.dateRange(startTime, endTime, options, "datetimepicker") }; $.timepicker.dateRange = function (startTime, endTime, options, method) { method = method || "datepicker"; $.timepicker.handleRange(method, startTime, endTime, options) }; $.timepicker.handleRange = function (method, startTime, endTime, options) { $.fn[method].call(startTime, $.extend({ onClose: function (dateText, inst) { checkDates(this, endTime, dateText) }, onSelect: function (selectedDateTime) { selected(this, endTime, "minDate") } }, options, options.start)); $.fn[method].call(endTime, $.extend({ onClose: function (dateText, inst) { checkDates(this, startTime, dateText) }, onSelect: function (selectedDateTime) { selected(this, startTime, "maxDate") } }, options, options.end)); if (method != "timepicker" && options.reformat) { $([startTime, endTime]).each(function () { var format = $(this)[method].call($(this), "option", "dateFormat"), date = new Date($(this).val()); if ($(this).val() && date) { $(this).val($.datepicker.formatDate(format, date)) } }) } checkDates(startTime, endTime, startTime.val()); function checkDates(changed, other, dateText) { if (other.val() && (new Date(startTime.val()) > new Date(endTime.val()))) { other.val(dateText) } } selected(startTime, endTime, "minDate"); selected(endTime, startTime, "maxDate"); function selected(changed, other, option) { if (!$(changed).val()) { return } var date = $(changed)[method].call($(changed), "getDate"); if (date.getTime) { $(other)[method].call($(other), "option", option, date) } } return $([startTime.get(0), endTime.get(0)]) }; $.timepicker.version = "1.1.1" })(jQuery);

jQuery.fn.scrollMinimal = function (smooth) {

    var cTop = this.offset().top;
    var cHeight = this.outerHeight(true);
    var windowTop = $(window).scrollTop();
    var visibleHeight = $(window).height();

    if (cTop < windowTop) {
        if (smooth) {
            $('body').animate({ 'scrollTop': cTop }, 'slow', 'swing');
        } else {
            $(window).scrollTop(cTop);
        }
    } else if (cTop + cHeight > windowTop + visibleHeight) {
        if (smooth) {
            $('body').animate({ 'scrollTop': cTop - visibleHeight + cHeight }, 'slow', 'swing');
        } else {
            $(window).scrollTop(cTop - visibleHeight + cHeight);
        }
    }

};

//XRegExp 2.0.0 <xregexp.com> MIT License
var XRegExp; XRegExp = XRegExp || function (n) { "use strict"; function v(n, i, r) { var u; for (u in t.prototype) t.prototype.hasOwnProperty(u) && (n[u] = t.prototype[u]); return n.xregexp = { captureNames: i, isNative: !!r }, n } function g(n) { return (n.global ? "g" : "") + (n.ignoreCase ? "i" : "") + (n.multiline ? "m" : "") + (n.extended ? "x" : "") + (n.sticky ? "y" : "") } function o(n, r, u) { if (!t.isRegExp(n)) throw new TypeError("type RegExp expected"); var f = i.replace.call(g(n) + (r || ""), h, ""); return u && (f = i.replace.call(f, new RegExp("[" + u + "]+", "g"), "")), n = n.xregexp && !n.xregexp.isNative ? v(t(n.source, f), n.xregexp.captureNames ? n.xregexp.captureNames.slice(0) : null) : v(new RegExp(n.source, f), null, !0) } function a(n, t) { var i = n.length; if (Array.prototype.lastIndexOf) return n.lastIndexOf(t); while (i--) if (n[i] === t) return i; return -1 } function s(n, t) { return Object.prototype.toString.call(n).toLowerCase() === "[object " + t + "]" } function d(n) { return n = n || {}, n === "all" || n.all ? n = { natives: !0, extensibility: !0 } : s(n, "string") && (n = t.forEach(n, /[^\s,]+/, function (n) { this[n] = !0 }, {})), n } function ut(n, t, i, u) { var o = p.length, s = null, e, f; y = !0; try { while (o--) if (f = p[o], (f.scope === "all" || f.scope === i) && (!f.trigger || f.trigger.call(u)) && (f.pattern.lastIndex = t, e = r.exec.call(f.pattern, n), e && e.index === t)) { s = { output: f.handler.call(u, e, i), match: e }; break } } catch (h) { throw h; } finally { y = !1 } return s } function b(n) { t.addToken = c[n ? "on" : "off"], f.extensibility = n } function tt(n) { RegExp.prototype.exec = (n ? r : i).exec, RegExp.prototype.test = (n ? r : i).test, String.prototype.match = (n ? r : i).match, String.prototype.replace = (n ? r : i).replace, String.prototype.split = (n ? r : i).split, f.natives = n } var t, c, u, f = { natives: !1, extensibility: !1 }, i = { exec: RegExp.prototype.exec, test: RegExp.prototype.test, match: String.prototype.match, replace: String.prototype.replace, split: String.prototype.split }, r = {}, k = {}, p = [], e = "default", rt = "class", it = { "default": /^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/, "class": /^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/ }, et = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g, h = /([\s\S])(?=[\s\S]*\1)/g, nt = /^(?:[?*+]|{\d+(?:,\d*)?})\??/, ft = i.exec.call(/()??/, "")[1] === n, l = RegExp.prototype.sticky !== n, y = !1, w = "gim" + (l ? "y" : ""); return t = function (r, u) { if (t.isRegExp(r)) { if (u !== n) throw new TypeError("can't supply flags when constructing one RegExp from another"); return o(r) } if (y) throw new Error("can't call the XRegExp constructor within token definition functions"); var l = [], a = e, b = { hasNamedCapture: !1, captureNames: [], hasFlag: function (n) { return u.indexOf(n) > -1 } }, f = 0, c, s, p; if (r = r === n ? "" : String(r), u = u === n ? "" : String(u), i.match.call(u, h)) throw new SyntaxError("invalid duplicate regular expression flag"); for (r = i.replace.call(r, /^\(\?([\w$]+)\)/, function (n, t) { if (i.test.call(/[gy]/, t)) throw new SyntaxError("can't use flag g or y in mode modifier"); return u = i.replace.call(u + t, h, ""), "" }), t.forEach(u, /[\s\S]/, function (n) { if (w.indexOf(n[0]) < 0) throw new SyntaxError("invalid regular expression flag " + n[0]); }) ; f < r.length;) c = ut(r, f, a, b), c ? (l.push(c.output), f += c.match[0].length || 1) : (s = i.exec.call(it[a], r.slice(f)), s ? (l.push(s[0]), f += s[0].length) : (p = r.charAt(f), p === "[" ? a = rt : p === "]" && (a = e), l.push(p), ++f)); return v(new RegExp(l.join(""), i.replace.call(u, /[^gimy]+/g, "")), b.hasNamedCapture ? b.captureNames : null) }, c = { on: function (n, t, r) { r = r || {}, n && p.push({ pattern: o(n, "g" + (l ? "y" : "")), handler: t, scope: r.scope || e, trigger: r.trigger || null }), r.customFlags && (w = i.replace.call(w + r.customFlags, h, "")) }, off: function () { throw new Error("extensibility must be installed before using addToken"); } }, t.addToken = c.off, t.cache = function (n, i) { var r = n + "/" + (i || ""); return k[r] || (k[r] = t(n, i)) }, t.escape = function (n) { return i.replace.call(n, /[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") }, t.exec = function (n, t, i, u) { var e = o(t, "g" + (u && l ? "y" : ""), u === !1 ? "y" : ""), f; return e.lastIndex = i = i || 0, f = r.exec.call(e, n), u && f && f.index !== i && (f = null), t.global && (t.lastIndex = f ? e.lastIndex : 0), f }, t.forEach = function (n, i, r, u) { for (var e = 0, o = -1, f; f = t.exec(n, i, e) ;) r.call(u, f, ++o, n, i), e = f.index + (f[0].length || 1); return u }, t.globalize = function (n) { return o(n, "g") }, t.install = function (n) { n = d(n), !f.natives && n.natives && tt(!0), !f.extensibility && n.extensibility && b(!0) }, t.isInstalled = function (n) { return !!f[n] }, t.isRegExp = function (n) { return s(n, "regexp") }, t.matchChain = function (n, i) { return function r(n, u) { for (var o = i[u].regex ? i[u] : { regex: i[u] }, f = [], s = function (n) { f.push(o.backref ? n[o.backref] || "" : n[0]) }, e = 0; e < n.length; ++e) t.forEach(n[e], o.regex, s); return u === i.length - 1 || !f.length ? f : r(f, u + 1) }([n], 0) }, t.replace = function (i, u, f, e) { var c = t.isRegExp(u), s = u, h; return c ? (e === n && u.global && (e = "all"), s = o(u, e === "all" ? "g" : "", e === "all" ? "" : "g")) : e === "all" && (s = new RegExp(t.escape(String(u)), "g")), h = r.replace.call(String(i), s, f), c && u.global && (u.lastIndex = 0), h }, t.split = function (n, t, i) { return r.split.call(n, t, i) }, t.test = function (n, i, r, u) { return !!t.exec(n, i, r, u) }, t.uninstall = function (n) { n = d(n), f.natives && n.natives && tt(!1), f.extensibility && n.extensibility && b(!1) }, t.union = function (n, i) { var l = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*]/g, o = 0, f, h, c = function (n, t, i) { var r = h[o - f]; if (t) { if (++o, r) return "(?<" + r + ">" } else if (i) return "\\" + (+i + f); return n }, e = [], r, u; if (!(s(n, "array") && n.length)) throw new TypeError("patterns must be a nonempty array"); for (u = 0; u < n.length; ++u) r = n[u], t.isRegExp(r) ? (f = o, h = r.xregexp && r.xregexp.captureNames || [], e.push(t(r.source).source.replace(l, c))) : e.push(t.escape(r)); return t(e.join("|"), i) }, t.version = "2.0.0", r.exec = function (t) { var r, f, e, o, u; if (this.global || (o = this.lastIndex), r = i.exec.apply(this, arguments), r) { if (!ft && r.length > 1 && a(r, "") > -1 && (e = new RegExp(this.source, i.replace.call(g(this), "g", "")), i.replace.call(String(t).slice(r.index), e, function () { for (var t = 1; t < arguments.length - 2; ++t) arguments[t] === n && (r[t] = n) })), this.xregexp && this.xregexp.captureNames) for (u = 1; u < r.length; ++u) f = this.xregexp.captureNames[u - 1], f && (r[f] = r[u]); this.global && !r[0].length && this.lastIndex > r.index && (this.lastIndex = r.index) } return this.global || (this.lastIndex = o), r }, r.test = function (n) { return !!r.exec.call(this, n) }, r.match = function (n) { if (t.isRegExp(n)) { if (n.global) { var u = i.match.apply(this, arguments); return n.lastIndex = 0, u } } else n = new RegExp(n); return r.exec.call(n, this) }, r.replace = function (n, r) { var e = t.isRegExp(n), u, f, h, o; return e ? (n.xregexp && (u = n.xregexp.captureNames), n.global || (o = n.lastIndex)) : n += "", s(r, "function") ? f = i.replace.call(String(this), n, function () { var t = arguments, i; if (u) for (t[0] = new String(t[0]), i = 0; i < u.length; ++i) u[i] && (t[0][u[i]] = t[i + 1]); return e && n.global && (n.lastIndex = t[t.length - 2] + t[0].length), r.apply(null, t) }) : (h = String(this), f = i.replace.call(h, n, function () { var n = arguments; return i.replace.call(String(r), et, function (t, i, r) { var f; if (i) { if (f = +i, f <= n.length - 3) return n[f] || ""; if (f = u ? a(u, i) : -1, f < 0) throw new SyntaxError("backreference to undefined group " + t); return n[f + 1] || "" } if (r === "$") return "$"; if (r === "&" || +r == 0) return n[0]; if (r === "`") return n[n.length - 1].slice(0, n[n.length - 2]); if (r === "'") return n[n.length - 1].slice(n[n.length - 2] + n[0].length); if (r = +r, !isNaN(r)) { if (r > n.length - 3) throw new SyntaxError("backreference to undefined group " + t); return n[r] || "" } throw new SyntaxError("invalid token " + t); }) })), e && (n.lastIndex = n.global ? 0 : o), f }, r.split = function (r, u) { if (!t.isRegExp(r)) return i.split.apply(this, arguments); var e = String(this), h = r.lastIndex, f = [], o = 0, s; return u = (u === n ? -1 : u) >>> 0, t.forEach(e, r, function (n) { n.index + n[0].length > o && (f.push(e.slice(o, n.index)), n.length > 1 && n.index < e.length && Array.prototype.push.apply(f, n.slice(1)), s = n[0].length, o = n.index + s) }), o === e.length ? (!i.test.call(r, "") || s) && f.push("") : f.push(e.slice(o)), r.lastIndex = h, f.length > u ? f.slice(0, u) : f }, u = c.on, u(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4})|x(?![\dA-Fa-f]{2}))/, function (n, t) { if (n[1] === "B" && t === e) return n[0]; throw new SyntaxError("invalid escape " + n[0]); }, { scope: "all" }), u(/\[(\^?)]/, function (n) { return n[1] ? "[\\s\\S]" : "\\b\\B" }), u(/(?:\(\?#[^)]*\))+/, function (n) { return i.test.call(nt, n.input.slice(n.index + n[0].length)) ? "" : "(?:)" }), u(/\\k<([\w$]+)>/, function (n) { var t = isNaN(n[1]) ? a(this.captureNames, n[1]) + 1 : +n[1], i = n.index + n[0].length; if (!t || t > this.captureNames.length) throw new SyntaxError("backreference to undefined group " + n[0]); return "\\" + t + (i === n.input.length || isNaN(n.input.charAt(i)) ? "" : "(?:)") }), u(/(?:\s+|#.*)+/, function (n) { return i.test.call(nt, n.input.slice(n.index + n[0].length)) ? "" : "(?:)" }, { trigger: function () { return this.hasFlag("x") }, customFlags: "x" }), u(/\./, function () { return "[\\s\\S]" }, { trigger: function () { return this.hasFlag("s") }, customFlags: "s" }), u(/\(\?P?<([\w$]+)>/, function (n) { if (!isNaN(n[1])) throw new SyntaxError("can't use integer as capture name " + n[0]); return this.captureNames.push(n[1]), this.hasNamedCapture = !0, "(" }), u(/\\(\d+)/, function (n, t) { if (!(t === e && /^[1-9]/.test(n[1]) && +n[1] <= this.captureNames.length) && n[1] !== "0") throw new SyntaxError("can't use octal escape or backreference to undefined group " + n[0]); return n[0] }, { scope: "all" }), u(/\((?!\?)/, function () { return this.hasFlag("n") ? "(?:" : (this.captureNames.push(null), "(") }, { customFlags: "n" }), typeof exports != "undefined" && (exports.XRegExp = t), t }();

/*! URI.js v1.8.3 http://medialize.github.com/URI.js/ */
/* build contains: IPv6.js, punycode.js, SecondLevelDomains.js, URI.js, URITemplate.js */
(function (f, g) { "object" === typeof exports ? module.exports = g() : "function" === typeof define && define.amd ? define(g) : f.IPv6 = g() })(this, function () {
    return {
        best: function (f) {
            f = f.toLowerCase().split(":"); var g = f.length, j = 8; "" === f[0] && "" === f[1] && "" === f[2] ? (f.shift(), f.shift()) : "" === f[0] && "" === f[1] ? f.shift() : "" === f[g - 1] && "" === f[g - 2] && f.pop(); g = f.length; -1 !== f[g - 1].indexOf(".") && (j = 7); var d; for (d = 0; d < g && "" !== f[d]; d++); if (d < j) for (f.splice(d, 1, "0000") ; f.length < j;) f.splice(d, 0, "0000"); for (d = 0; d < j; d++) {
                for (var g = f[d].split(""),
                m = 0; 3 > m; m++) if ("0" === g[0] && 1 < g.length) g.splice(0, 1); else break; f[d] = g.join("")
            } var g = -1, u = m = 0, h = -1, c = !1; for (d = 0; d < j; d++) c ? "0" === f[d] ? u += 1 : (c = !1, u > m && (g = h, m = u)) : "0" == f[d] && (c = !0, h = d, u = 1); u > m && (g = h, m = u); 1 < m && f.splice(g, m, ""); g = f.length; j = ""; "" === f[0] && (beststr = ":"); for (d = 0; d < g; d++) { j += f[d]; if (d === g - 1) break; j += ":" } "" === f[g - 1] && (j += ":"); return j
        }
    }
});
(function (f) {
    function g(a) { throw RangeError(D[a]); } function j(a, b) { for (var e = a.length; e--;) a[e] = b(a[e]); return a } function d(a) { for (var b = [], e = 0, d = a.length, t, c; e < d;) t = a.charCodeAt(e++), 55296 == (t & 63488) && e < d ? (c = a.charCodeAt(e++), 56320 == (c & 64512) ? b.push(((t & 1023) << 10) + (c & 1023) + 65536) : b.push(t, c)) : b.push(t); return b } function m(a) { return j(a, function (a) { var b = ""; 65535 < a && (a -= 65536, b += A(a >>> 10 & 1023 | 55296), a = 56320 | a & 1023); return b += A(a) }).join("") } function u(e, d, t) {
        var c = 0; e = t ? x(e / b) : e >> 1; for (e += x(e / d) ; e >
        y * s >> 1; c += l) e = x(e / y); return x(c + (y + 1) * e / (e + a))
    } function h(a) {
        var b = [], d = a.length, c, h = 0, f = t, w = e, q, j, n, k, r; q = a.lastIndexOf(C); 0 > q && (q = 0); for (j = 0; j < q; ++j) 128 <= a.charCodeAt(j) && g("not-basic"), b.push(a.charCodeAt(j)); for (q = 0 < q ? q + 1 : 0; q < d;) {
            j = h; c = 1; for (n = l; ; n += l) { q >= d && g("invalid-input"); k = a.charCodeAt(q++); k = 10 > k - 48 ? k - 22 : 26 > k - 65 ? k - 65 : 26 > k - 97 ? k - 97 : l; (k >= l || k > x((p - h) / c)) && g("overflow"); h += k * c; r = n <= w ? v : n >= w + s ? s : n - w; if (k < r) break; k = l - r; c > x(p / k) && g("overflow"); c *= k } c = b.length + 1; w = u(h - j, c, 0 == j); x(h / c) > p - f && g("overflow");
            f += x(h / c); h %= c; b.splice(h++, 0, f)
        } return m(b)
    } function c(a) {
        var b, c, h, f, w, q, k, j, n, r = [], m, z, y; a = d(a); m = a.length; b = t; c = 0; w = e; for (q = 0; q < m; ++q) n = a[q], 128 > n && r.push(A(n)); for ((h = f = r.length) && r.push(C) ; h < m;) {
            k = p; for (q = 0; q < m; ++q) n = a[q], n >= b && n < k && (k = n); z = h + 1; k - b > x((p - c) / z) && g("overflow"); c += (k - b) * z; b = k; for (q = 0; q < m; ++q) if (n = a[q], n < b && ++c > p && g("overflow"), n == b) {
                j = c; for (k = l; ; k += l) { n = k <= w ? v : k >= w + s ? s : k - w; if (j < n) break; y = j - n; j = l - n; r.push(A(n + y % j + 22 + 75 * (26 > n + y % j) - 0)); j = x(y / j) } r.push(A(j + 22 + 75 * (26 > j) - 0)); w = u(c, z,
                h == f); c = 0; ++h
            } ++c; ++b
        } return r.join("")
    } var q, n = "function" == typeof define && "object" == typeof define.amd && define.amd && define, k = "object" == typeof exports && exports, r = "object" == typeof module && module, p = 2147483647, l = 36, v = 1, s = 26, a = 38, b = 700, e = 72, t = 128, C = "-", w = /[^ -~]/, z = /^xn--/, D = { overflow: "Overflow: input needs wider integers to process.", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, y = l - v, x = Math.floor, A = String.fromCharCode, B; q = {
        version: "1.1.1", ucs2: {
            decode: d,
            encode: m
        }, decode: h, encode: c, toASCII: function (a) { return j(a.split("."), function (a) { return w.test(a) ? "xn--" + c(a) : a }).join(".") }, toUnicode: function (a) { return j(a.split("."), function (a) { return z.test(a) ? h(a.slice(4).toLowerCase()) : a }).join(".") }
    }; if (k) if (r && r.exports == k) r.exports = q; else for (B in q) q.hasOwnProperty(B) && (k[B] = q[B]); else n ? define("punycode", q) : f.punycode = q
})(this);
(function (f, g) { "object" === typeof exports ? module.exports = g() : "function" === typeof define && define.amd ? define(g) : f.SecondLevelDomains = g() })(this, function () {
    var f = Object.prototype.hasOwnProperty, g = {
        list: {
            ac: "com|gov|mil|net|org", ae: "ac|co|gov|mil|name|net|org|pro|sch", af: "com|edu|gov|net|org", al: "com|edu|gov|mil|net|org", ao: "co|ed|gv|it|og|pb", ar: "com|edu|gob|gov|int|mil|net|org|tur", at: "ac|co|gv|or", au: "asn|com|csiro|edu|gov|id|net|org", ba: "co|com|edu|gov|mil|net|org|rs|unbi|unmo|unsa|untz|unze", bb: "biz|co|com|edu|gov|info|net|org|store|tv",
            bh: "biz|cc|com|edu|gov|info|net|org", bn: "com|edu|gov|net|org", bo: "com|edu|gob|gov|int|mil|net|org|tv", br: "adm|adv|agr|am|arq|art|ato|b|bio|blog|bmd|cim|cng|cnt|com|coop|ecn|edu|eng|esp|etc|eti|far|flog|fm|fnd|fot|fst|g12|ggf|gov|imb|ind|inf|jor|jus|lel|mat|med|mil|mus|net|nom|not|ntr|odo|org|ppg|pro|psc|psi|qsl|rec|slg|srv|tmp|trd|tur|tv|vet|vlog|wiki|zlg", bs: "com|edu|gov|net|org", bz: "du|et|om|ov|rg", ca: "ab|bc|mb|nb|nf|nl|ns|nt|nu|on|pe|qc|sk|yk", ck: "biz|co|edu|gen|gov|info|net|org", cn: "ac|ah|bj|com|cq|edu|fj|gd|gov|gs|gx|gz|ha|hb|he|hi|hl|hn|jl|js|jx|ln|mil|net|nm|nx|org|qh|sc|sd|sh|sn|sx|tj|tw|xj|xz|yn|zj",
            co: "com|edu|gov|mil|net|nom|org", cr: "ac|c|co|ed|fi|go|or|sa", cy: "ac|biz|com|ekloges|gov|ltd|name|net|org|parliament|press|pro|tm", "do": "art|com|edu|gob|gov|mil|net|org|sld|web", dz: "art|asso|com|edu|gov|net|org|pol", ec: "com|edu|fin|gov|info|med|mil|net|org|pro", eg: "com|edu|eun|gov|mil|name|net|org|sci", er: "com|edu|gov|ind|mil|net|org|rochest|w", es: "com|edu|gob|nom|org", et: "biz|com|edu|gov|info|name|net|org", fj: "ac|biz|com|info|mil|name|net|org|pro", fk: "ac|co|gov|net|nom|org", fr: "asso|com|f|gouv|nom|prd|presse|tm",
            gg: "co|net|org", gh: "com|edu|gov|mil|org", gn: "ac|com|gov|net|org", gr: "com|edu|gov|mil|net|org", gt: "com|edu|gob|ind|mil|net|org", gu: "com|edu|gov|net|org", hk: "com|edu|gov|idv|net|org", id: "ac|co|go|mil|net|or|sch|web", il: "ac|co|gov|idf|k12|muni|net|org", "in": "ac|co|edu|ernet|firm|gen|gov|i|ind|mil|net|nic|org|res", iq: "com|edu|gov|i|mil|net|org", ir: "ac|co|dnssec|gov|i|id|net|org|sch", it: "edu|gov", je: "co|net|org", jo: "com|edu|gov|mil|name|net|org|sch", jp: "ac|ad|co|ed|go|gr|lg|ne|or", ke: "ac|co|go|info|me|mobi|ne|or|sc",
            kh: "com|edu|gov|mil|net|org|per", ki: "biz|com|de|edu|gov|info|mob|net|org|tel", km: "asso|com|coop|edu|gouv|k|medecin|mil|nom|notaires|pharmaciens|presse|tm|veterinaire", kn: "edu|gov|net|org", kr: "ac|busan|chungbuk|chungnam|co|daegu|daejeon|es|gangwon|go|gwangju|gyeongbuk|gyeonggi|gyeongnam|hs|incheon|jeju|jeonbuk|jeonnam|k|kg|mil|ms|ne|or|pe|re|sc|seoul|ulsan", kw: "com|edu|gov|net|org", ky: "com|edu|gov|net|org", kz: "com|edu|gov|mil|net|org", lb: "com|edu|gov|net|org", lk: "assn|com|edu|gov|grp|hotel|int|ltd|net|ngo|org|sch|soc|web",
            lr: "com|edu|gov|net|org", lv: "asn|com|conf|edu|gov|id|mil|net|org", ly: "com|edu|gov|id|med|net|org|plc|sch", ma: "ac|co|gov|m|net|org|press", mc: "asso|tm", me: "ac|co|edu|gov|its|net|org|priv", mg: "com|edu|gov|mil|nom|org|prd|tm", mk: "com|edu|gov|inf|name|net|org|pro", ml: "com|edu|gov|net|org|presse", mn: "edu|gov|org", mo: "com|edu|gov|net|org", mt: "com|edu|gov|net|org", mv: "aero|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro", mw: "ac|co|com|coop|edu|gov|int|museum|net|org", mx: "com|edu|gob|net|org", my: "com|edu|gov|mil|name|net|org|sch",
            nf: "arts|com|firm|info|net|other|per|rec|store|web", ng: "biz|com|edu|gov|mil|mobi|name|net|org|sch", ni: "ac|co|com|edu|gob|mil|net|nom|org", np: "com|edu|gov|mil|net|org", nr: "biz|com|edu|gov|info|net|org", om: "ac|biz|co|com|edu|gov|med|mil|museum|net|org|pro|sch", pe: "com|edu|gob|mil|net|nom|org|sld", ph: "com|edu|gov|i|mil|net|ngo|org", pk: "biz|com|edu|fam|gob|gok|gon|gop|gos|gov|net|org|web", pl: "art|bialystok|biz|com|edu|gda|gdansk|gorzow|gov|info|katowice|krakow|lodz|lublin|mil|net|ngo|olsztyn|org|poznan|pwr|radom|slupsk|szczecin|torun|warszawa|waw|wroc|wroclaw|zgora",
            pr: "ac|biz|com|edu|est|gov|info|isla|name|net|org|pro|prof", ps: "com|edu|gov|net|org|plo|sec", pw: "belau|co|ed|go|ne|or", ro: "arts|com|firm|info|nom|nt|org|rec|store|tm|www", rs: "ac|co|edu|gov|in|org", sb: "com|edu|gov|net|org", sc: "com|edu|gov|net|org", sh: "co|com|edu|gov|net|nom|org", sl: "com|edu|gov|net|org", st: "co|com|consulado|edu|embaixada|gov|mil|net|org|principe|saotome|store", sv: "com|edu|gob|org|red", sz: "ac|co|org", tr: "av|bbs|bel|biz|com|dr|edu|gen|gov|info|k12|name|net|org|pol|tel|tsk|tv|web", tt: "aero|biz|cat|co|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel",
            tw: "club|com|ebiz|edu|game|gov|idv|mil|net|org", mu: "ac|co|com|gov|net|or|org", mz: "ac|co|edu|gov|org", na: "co|com", nz: "ac|co|cri|geek|gen|govt|health|iwi|maori|mil|net|org|parliament|school", pa: "abo|ac|com|edu|gob|ing|med|net|nom|org|sld", pt: "com|edu|gov|int|net|nome|org|publ", py: "com|edu|gov|mil|net|org", qa: "com|edu|gov|mil|net|org", re: "asso|com|nom", ru: "ac|adygeya|altai|amur|arkhangelsk|astrakhan|bashkiria|belgorod|bir|bryansk|buryatia|cbg|chel|chelyabinsk|chita|chukotka|chuvashia|com|dagestan|e-burg|edu|gov|grozny|int|irkutsk|ivanovo|izhevsk|jar|joshkar-ola|kalmykia|kaluga|kamchatka|karelia|kazan|kchr|kemerovo|khabarovsk|khakassia|khv|kirov|koenig|komi|kostroma|kranoyarsk|kuban|kurgan|kursk|lipetsk|magadan|mari|mari-el|marine|mil|mordovia|mosreg|msk|murmansk|nalchik|net|nnov|nov|novosibirsk|nsk|omsk|orenburg|org|oryol|penza|perm|pp|pskov|ptz|rnd|ryazan|sakhalin|samara|saratov|simbirsk|smolensk|spb|stavropol|stv|surgut|tambov|tatarstan|tom|tomsk|tsaritsyn|tsk|tula|tuva|tver|tyumen|udm|udmurtia|ulan-ude|vladikavkaz|vladimir|vladivostok|volgograd|vologda|voronezh|vrn|vyatka|yakutia|yamal|yekaterinburg|yuzhno-sakhalinsk",
            rw: "ac|co|com|edu|gouv|gov|int|mil|net", sa: "com|edu|gov|med|net|org|pub|sch", sd: "com|edu|gov|info|med|net|org|tv", se: "a|ac|b|bd|c|d|e|f|g|h|i|k|l|m|n|o|org|p|parti|pp|press|r|s|t|tm|u|w|x|y|z", sg: "com|edu|gov|idn|net|org|per", sn: "art|com|edu|gouv|org|perso|univ", sy: "com|edu|gov|mil|net|news|org", th: "ac|co|go|in|mi|net|or", tj: "ac|biz|co|com|edu|go|gov|info|int|mil|name|net|nic|org|test|web", tn: "agrinet|com|defense|edunet|ens|fin|gov|ind|info|intl|mincom|nat|net|org|perso|rnrt|rns|rnu|tourism", tz: "ac|co|go|ne|or",
            ua: "biz|cherkassy|chernigov|chernovtsy|ck|cn|co|com|crimea|cv|dn|dnepropetrovsk|donetsk|dp|edu|gov|if|in|ivano-frankivsk|kh|kharkov|kherson|khmelnitskiy|kiev|kirovograd|km|kr|ks|kv|lg|lugansk|lutsk|lviv|me|mk|net|nikolaev|od|odessa|org|pl|poltava|pp|rovno|rv|sebastopol|sumy|te|ternopil|uzhgorod|vinnica|vn|zaporizhzhe|zhitomir|zp|zt", ug: "ac|co|go|ne|or|org|sc", uk: "ac|bl|british-library|co|cym|gov|govt|icnet|jet|lea|ltd|me|mil|mod|national-library-scotland|nel|net|nhs|nic|nls|org|orgn|parliament|plc|police|sch|scot|soc",
            us: "dni|fed|isa|kids|nsn", uy: "com|edu|gub|mil|net|org", ve: "co|com|edu|gob|info|mil|net|org|web", vi: "co|com|k12|net|org", vn: "ac|biz|com|edu|gov|health|info|int|name|net|org|pro", ye: "co|com|gov|ltd|me|net|org|plc", yu: "ac|co|edu|gov|org", za: "ac|agric|alt|bourse|city|co|cybernet|db|edu|gov|grondar|iaccess|imt|inca|landesign|law|mil|net|ngo|nis|nom|olivetti|org|pix|school|tm|web", zm: "ac|co|com|edu|gov|net|org|sch"
        }, has_expression: null, is_expression: null, has: function (f) { return !!f.match(g.has_expression) },
        is: function (f) { return !!f.match(g.is_expression) }, get: function (f) { return (f = f.match(g.has_expression)) && f[1] || null }, init: function () { var j = "", d; for (d in g.list) f.call(g.list, d) && (j += "|(" + ("(" + g.list[d] + ")." + d) + ")"); g.has_expression = RegExp("\\.(" + j.substr(1) + ")$", "i"); g.is_expression = RegExp("^(" + j.substr(1) + ")$", "i") }
    }; g.init(); return g
});
(function (f, g) { "object" === typeof exports ? module.exports = g(require("./punycode"), require("./IPv6"), require("./SecondLevelDomains")) : "function" === typeof define && define.amd ? define(["./punycode", "./IPv6", "./SecondLevelDomains"], g) : f.URI = g(f.punycode, f.IPv6, f.SecondLevelDomains) })(this, function (f, g, j) {
    function d(a, b) { if (!(this instanceof d)) return new d(a, b); void 0 === a && (a = "undefined" !== typeof location ? location.href + "" : ""); this.href(a); return void 0 !== b ? this.absoluteTo(b) : this } function m(a) {
        return a.replace(/([.*+?^=!:${}()|[\]\/\\])/g,
        "\\$1")
    } function u(a) { return "[object Array]" === String(Object.prototype.toString.call(a)) } function h(a) { return encodeURIComponent(a).replace(/[!'()*]/g, escape).replace(/\*/g, "%2A") } var c = d.prototype, q = Object.prototype.hasOwnProperty; d._parts = function () { return { protocol: null, username: null, password: null, hostname: null, urn: null, port: null, path: null, query: null, fragment: null, duplicateQueryParameters: d.duplicateQueryParameters } }; d.duplicateQueryParameters = !1; d.protocol_expression = /^[a-z][a-z0-9-+-]*$/i; d.idn_expression =
    /[^a-z0-9\.-]/i; d.punycode_expression = /(xn--)/i; d.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/; d.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
    d.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?\u00ab\u00bb\u201c\u201d\u2018\u2019]))/ig; d.defaultPorts = { http: "80", https: "443", ftp: "21", gopher: "70", ws: "80", wss: "443" }; d.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/; d.encode = h; d.decode = decodeURIComponent; d.iso8859 = function () { d.encode = escape; d.decode = unescape }; d.unicode = function () {
        d.encode =
        h; d.decode = decodeURIComponent
    }; d.characters = {
        pathname: { encode: { expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig, map: { "%24": "$", "%26": "&", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%3A": ":", "%40": "@" } }, decode: { expression: /[\/\?#]/g, map: { "/": "%2F", "?": "%3F", "#": "%23" } } }, reserved: {
            encode: {
                expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig, map: {
                    "%3A": ":", "%2F": "/", "%3F": "?", "%23": "#", "%5B": "[", "%5D": "]", "%40": "@", "%21": "!", "%24": "$", "%26": "&", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+",
                    "%2C": ",", "%3B": ";", "%3D": "="
                }
            }
        }
    }; d.encodeQuery = function (a) { return d.encode(a + "").replace(/%20/g, "+") }; d.decodeQuery = function (a) { return d.decode((a + "").replace(/\+/g, "%20")) }; d.recodePath = function (a) { a = (a + "").split("/"); for (var b = 0, e = a.length; b < e; b++) a[b] = d.encodePathSegment(d.decode(a[b])); return a.join("/") }; d.decodePath = function (a) { a = (a + "").split("/"); for (var b = 0, e = a.length; b < e; b++) a[b] = d.decodePathSegment(a[b]); return a.join("/") }; var n = { encode: "encode", decode: "decode" }, k, r = function (a, b) {
        return function (e) {
            return d[b](e +
            "").replace(d.characters[a][b].expression, function (e) { return d.characters[a][b].map[e] })
        }
    }; for (k in n) d[k + "PathSegment"] = r("pathname", n[k]); d.encodeReserved = r("reserved", "encode"); d.parse = function (a, b) {
        var e; b || (b = {}); e = a.indexOf("#"); -1 < e && (b.fragment = a.substring(e + 1) || null, a = a.substring(0, e)); e = a.indexOf("?"); -1 < e && (b.query = a.substring(e + 1) || null, a = a.substring(0, e)); "//" === a.substring(0, 2) ? (b.protocol = "", a = a.substring(2), a = d.parseAuthority(a, b)) : (e = a.indexOf(":"), -1 < e && (b.protocol = a.substring(0,
        e), b.protocol && !b.protocol.match(d.protocol_expression) ? b.protocol = void 0 : "file" === b.protocol ? a = a.substring(e + 3) : "//" === a.substring(e + 1, e + 3) ? (a = a.substring(e + 3), a = d.parseAuthority(a, b)) : (a = a.substring(e + 1), b.urn = !0))); b.path = a; return b
    }; d.parseHost = function (a, b) {
        var e = a.indexOf("/"), d; -1 === e && (e = a.length); "[" === a[0] ? (d = a.indexOf("]"), b.hostname = a.substring(1, d) || null, b.port = a.substring(d + 2, e) || null) : a.indexOf(":") !== a.lastIndexOf(":") ? (b.hostname = a.substring(0, e) || null, b.port = null) : (d = a.substring(0,
        e).split(":"), b.hostname = d[0] || null, b.port = d[1] || null); b.hostname && "/" !== a.substring(e)[0] && (e++, a = "/" + a); return a.substring(e) || "/"
    }; d.parseAuthority = function (a, b) { a = d.parseUserinfo(a, b); return d.parseHost(a, b) }; d.parseUserinfo = function (a, b) { var e = a.indexOf("@"), t = a.indexOf("/"); -1 < e && (-1 === t || e < t) ? (t = a.substring(0, e).split(":"), b.username = t[0] ? d.decode(t[0]) : null, t.shift(), b.password = t[0] ? d.decode(t.join(":")) : null, a = a.substring(e + 1)) : (b.username = null, b.password = null); return a }; d.parseQuery = function (a) {
        if (!a) return {};
        a = a.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""); if (!a) return {}; var b = {}; a = a.split("&"); for (var e = a.length, t, c, h = 0; h < e; h++) t = a[h].split("="), c = d.decodeQuery(t.shift()), t = t.length ? d.decodeQuery(t.join("=")) : null, b[c] ? ("string" === typeof b[c] && (b[c] = [b[c]]), b[c].push(t)) : b[c] = t; return b
    }; d.build = function (a) {
        var b = ""; a.protocol && (b += a.protocol + ":"); if (!a.urn && (b || a.hostname)) b += "//"; b += d.buildAuthority(a) || ""; "string" === typeof a.path && ("/" !== a.path[0] && "string" === typeof a.hostname && (b += "/"), b += a.path);
        "string" === typeof a.query && a.query && (b += "?" + a.query); "string" === typeof a.fragment && a.fragment && (b += "#" + a.fragment); return b
    }; d.buildHost = function (a) { var b = ""; if (a.hostname) d.ip6_expression.test(a.hostname) ? b = a.port ? b + ("[" + a.hostname + "]:" + a.port) : b + a.hostname : (b += a.hostname, a.port && (b += ":" + a.port)); else return ""; return b }; d.buildAuthority = function (a) { return d.buildUserinfo(a) + d.buildHost(a) }; d.buildUserinfo = function (a) {
        var b = ""; a.username && (b += d.encode(a.username), a.password && (b += ":" + d.encode(a.password)),
        b += "@"); return b
    }; d.buildQuery = function (a, b) { var e = "", c, h, f, g; for (h in a) if (q.call(a, h) && h) if (u(a[h])) { c = {}; f = 0; for (g = a[h].length; f < g; f++) void 0 !== a[h][f] && void 0 === c[a[h][f] + ""] && (e += "&" + d.buildQueryParameter(h, a[h][f]), !0 !== b && (c[a[h][f] + ""] = !0)) } else void 0 !== a[h] && (e += "&" + d.buildQueryParameter(h, a[h])); return e.substring(1) }; d.buildQueryParameter = function (a, b) { return d.encodeQuery(a) + (null !== b ? "=" + d.encodeQuery(b) : "") }; d.addQuery = function (a, b, e) {
        if ("object" === typeof b) for (var c in b) q.call(b,
        c) && d.addQuery(a, c, b[c]); else if ("string" === typeof b) void 0 === a[b] ? a[b] = e : ("string" === typeof a[b] && (a[b] = [a[b]]), u(e) || (e = [e]), a[b] = a[b].concat(e)); else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
    }; d.removeQuery = function (a, b, e) {
        var c; if (u(b)) { e = 0; for (c = b.length; e < c; e++) a[b[e]] = void 0 } else if ("object" === typeof b) for (c in b) q.call(b, c) && d.removeQuery(a, c, b[c]); else if ("string" === typeof b) if (void 0 !== e) if (a[b] === e) a[b] = void 0; else {
            if (u(a[b])) {
                c = a[b]; var h = {},
                f, g; if (u(e)) { f = 0; for (g = e.length; f < g; f++) h[e[f]] = !0 } else h[e] = !0; f = 0; for (g = c.length; f < g; f++) void 0 !== h[c[f]] && (c.splice(f, 1), g--, f--); a[b] = c
            }
        } else a[b] = void 0; else throw new TypeError("URI.addQuery() accepts an object, string as the first parameter");
    }; d.commonPath = function (a, b) { var e = Math.min(a.length, b.length), d; for (d = 0; d < e; d++) if (a[d] !== b[d]) { d--; break } if (1 > d) return a[0] === b[0] && "/" === a[0] ? "/" : ""; "/" !== a[d] && (d = a.substring(0, d).lastIndexOf("/")); return a.substring(0, d + 1) }; d.withinString = function (a,
    b) { return a.replace(d.find_uri_expression, b) }; d.ensureValidHostname = function (a) { if (a.match(d.invalid_hostname_characters)) { if (!f) throw new TypeError("Hostname '" + a + "' contains characters other than [A-Z0-9.-] and Punycode.js is not available"); if (f.toASCII(a).match(d.invalid_hostname_characters)) throw new TypeError("Hostname '" + a + "' contains characters other than [A-Z0-9.-]"); } }; c.build = function (a) {
        if (!0 === a) this._deferred_build = !0; else if (void 0 === a || this._deferred_build) this._string = d.build(this._parts),
        this._deferred_build = !1; return this
    }; c.clone = function () { return new d(this) }; c.valueOf = c.toString = function () { return this.build(!1)._string }; n = { protocol: "protocol", username: "username", password: "password", hostname: "hostname", port: "port" }; r = function (a) { return function (b, e) { if (void 0 === b) return this._parts[a] || ""; this._parts[a] = b; this.build(!e); return this } }; for (k in n) c[k] = r(n[k]); n = { query: "?", fragment: "#" }; r = function (a, b) {
        return function (e, d) {
            if (void 0 === e) return this._parts[a] || ""; null !== e && (e += "",
            e[0] === b && (e = e.substring(1))); this._parts[a] = e; this.build(!d); return this
        }
    }; for (k in n) c[k] = r(k, n[k]); n = { search: ["?", "query"], hash: ["#", "fragment"] }; r = function (a, b) { return function (e, d) { var c = this[a](e, d); return "string" === typeof c && c.length ? b + c : c } }; for (k in n) c[k] = r(n[k][1], n[k][0]); c.pathname = function (a, b) { if (void 0 === a || !0 === a) { var e = this._parts.path || (this._parts.urn ? "" : "/"); return a ? d.decodePath(e) : e } this._parts.path = a ? d.recodePath(a) : "/"; this.build(!b); return this }; c.path = c.pathname; c.href = function (a,
    b) { var e; if (void 0 === a) return this.toString(); this._string = ""; this._parts = d._parts(); var c = a instanceof d, h = "object" === typeof a && (a.hostname || a.path); !c && (h && "[object Object]" !== Object.prototype.toString.call(a)) && (a = a.toString()); if ("string" === typeof a) this._parts = d.parse(a, this._parts); else if (c || h) for (e in c = c ? a._parts : a, c) q.call(this._parts, e) && (this._parts[e] = c[e]); else throw new TypeError("invalid input"); this.build(!b); return this }; c.is = function (a) {
        var b = !1, e = !1, c = !1, h = !1, f = !1, g = !1, q = !1, k =
        !this._parts.urn; this._parts.hostname && (k = !1, e = d.ip4_expression.test(this._parts.hostname), c = d.ip6_expression.test(this._parts.hostname), b = e || c, f = (h = !b) && j && j.has(this._parts.hostname), g = h && d.idn_expression.test(this._parts.hostname), q = h && d.punycode_expression.test(this._parts.hostname)); switch (a.toLowerCase()) {
            case "relative": return k; case "absolute": return !k; case "domain": case "name": return h; case "sld": return f; case "ip": return b; case "ip4": case "ipv4": case "inet4": return e; case "ip6": case "ipv6": case "inet6": return c;
            case "idn": return g; case "url": return !this._parts.urn; case "urn": return !!this._parts.urn; case "punycode": return q
        } return null
    }; var p = c.protocol, l = c.port, v = c.hostname; c.protocol = function (a, b) { if (void 0 !== a && a && (a = a.replace(/:(\/\/)?$/, ""), a.match(/[^a-zA-z0-9\.+-]/))) throw new TypeError("Protocol '" + a + "' contains characters other than [A-Z0-9.+-]"); return p.call(this, a, b) }; c.scheme = c.protocol; c.port = function (a, b) {
        if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 !== a && (0 === a && (a = null), a && (a += "",
        ":" === a[0] && (a = a.substring(1)), a.match(/[^0-9]/)))) throw new TypeError("Port '" + a + "' contains characters other than [0-9]"); return l.call(this, a, b)
    }; c.hostname = function (a, b) { if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 !== a) { var e = {}; d.parseHost(a, e); a = e.hostname } return v.call(this, a, b) }; c.host = function (a, b) { if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 === a) return this._parts.hostname ? d.buildHost(this._parts) : ""; d.parseHost(a, this._parts); this.build(!b); return this }; c.authority =
    function (a, b) { if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 === a) return this._parts.hostname ? d.buildAuthority(this._parts) : ""; d.parseAuthority(a, this._parts); this.build(!b); return this }; c.userinfo = function (a, b) { if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 === a) { if (!this._parts.username) return ""; var e = d.buildUserinfo(this._parts); return e.substring(0, e.length - 1) } "@" !== a[a.length - 1] && (a += "@"); d.parseUserinfo(a, this._parts); this.build(!b); return this }; c.resource = function (a, b) {
        var e;
        if (void 0 === a) return this.path() + this.search() + this.hash(); e = d.parse(a); this._parts.path = e.path; this._parts.query = e.query; this._parts.fragment = e.fragment; this.build(!b); return this
    }; c.subdomain = function (a, b) {
        if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 === a) { if (!this._parts.hostname || this.is("IP")) return ""; var e = this._parts.hostname.length - this.domain().length - 1; return this._parts.hostname.substring(0, e) || "" } e = this._parts.hostname.length - this.domain().length; e = this._parts.hostname.substring(0,
        e); e = RegExp("^" + m(e)); a && "." !== a[a.length - 1] && (a += "."); a && d.ensureValidHostname(a); this._parts.hostname = this._parts.hostname.replace(e, a); this.build(!b); return this
    }; c.domain = function (a, b) {
        if (this._parts.urn) return void 0 === a ? "" : this; "boolean" === typeof a && (b = a, a = void 0); if (void 0 === a) {
            if (!this._parts.hostname || this.is("IP")) return ""; var e = this._parts.hostname.match(/\./g); if (e && 2 > e.length) return this._parts.hostname; e = this._parts.hostname.length - this.tld(b).length - 1; e = this._parts.hostname.lastIndexOf(".",
            e - 1) + 1; return this._parts.hostname.substring(e) || ""
        } if (!a) throw new TypeError("cannot set domain empty"); d.ensureValidHostname(a); !this._parts.hostname || this.is("IP") ? this._parts.hostname = a : (e = RegExp(m(this.domain()) + "$"), this._parts.hostname = this._parts.hostname.replace(e, a)); this.build(!b); return this
    }; c.tld = function (a, b) {
        if (this._parts.urn) return void 0 === a ? "" : this; "boolean" === typeof a && (b = a, a = void 0); if (void 0 === a) {
            if (!this._parts.hostname || this.is("IP")) return ""; var e = this._parts.hostname.lastIndexOf("."),
            e = this._parts.hostname.substring(e + 1); return !0 !== b && j && j.list[e.toLowerCase()] ? j.get(this._parts.hostname) || e : e
        } if (a) if (a.match(/[^a-zA-Z0-9-]/)) if (j && j.is(a)) e = RegExp(m(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(e, a); else throw new TypeError("TLD '" + a + "' contains characters other than [A-Z0-9]"); else {
            if (!this._parts.hostname || this.is("IP")) throw new ReferenceError("cannot set TLD on non-domain host"); e = RegExp(m(this.tld()) + "$"); this._parts.hostname = this._parts.hostname.replace(e,
            a)
        } else throw new TypeError("cannot set TLD empty"); this.build(!b); return this
    }; c.directory = function (a, b) {
        if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 === a || !0 === a) { if (!this._parts.path && !this._parts.hostname) return ""; if ("/" === this._parts.path) return "/"; var e = this._parts.path.length - this.filename().length - 1, e = this._parts.path.substring(0, e) || (this._parts.hostname ? "/" : ""); return a ? d.decodePath(e) : e } e = this._parts.path.length - this.filename().length; e = this._parts.path.substring(0, e); e = RegExp("^" +
        m(e)); this.is("relative") || (a || (a = "/"), "/" !== a[0] && (a = "/" + a)); a && "/" !== a[a.length - 1] && (a += "/"); a = d.recodePath(a); this._parts.path = this._parts.path.replace(e, a); this.build(!b); return this
    }; c.filename = function (a, b) {
        if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 === a || !0 === a) { if (!this._parts.path || "/" === this._parts.path) return ""; var e = this._parts.path.lastIndexOf("/"), e = this._parts.path.substring(e + 1); return a ? d.decodePathSegment(e) : e } e = !1; "/" === a[0] && (a = a.substring(1)); a.match(/\.?\//) && (e = !0);
        var c = RegExp(m(this.filename()) + "$"); a = d.recodePath(a); this._parts.path = this._parts.path.replace(c, a); e ? this.normalizePath(b) : this.build(!b); return this
    }; c.suffix = function (a, b) {
        if (this._parts.urn) return void 0 === a ? "" : this; if (void 0 === a || !0 === a) { if (!this._parts.path || "/" === this._parts.path) return ""; var e = this.filename(), c = e.lastIndexOf("."); if (-1 === c) return ""; e = e.substring(c + 1); e = /^[a-z0-9%]+$/i.test(e) ? e : ""; return a ? d.decodePathSegment(e) : e } "." === a[0] && (a = a.substring(1)); if (e = this.suffix()) c = a ? RegExp(m(e) +
        "$") : RegExp(m("." + e) + "$"); else { if (!a) return this; this._parts.path += "." + d.recodePath(a) } c && (a = d.recodePath(a), this._parts.path = this._parts.path.replace(c, a)); this.build(!b); return this
    }; c.segment = function (a, b, e) {
        var d = this._parts.urn ? ":" : "/", c = this.path(), h = "/" === c.substring(0, 1), c = c.split(d); "number" !== typeof a && (e = b, b = a, a = void 0); if (void 0 !== a && "number" !== typeof a) throw Error("Bad segment '" + a + "', must be 0-based integer"); h && c.shift(); 0 > a && (a = Math.max(c.length + a, 0)); if (void 0 === b) return void 0 ===
        a ? c : c[a]; if (null === a || void 0 === c[a]) if (u(b)) c = b; else { if (b || "string" === typeof b && b.length) "" === c[c.length - 1] ? c[c.length - 1] = b : c.push(b) } else b || "string" === typeof b && b.length ? c[a] = b : c.splice(a, 1); h && c.unshift(""); return this.path(c.join(d), e)
    }; var s = c.query; c.query = function (a, b) { return !0 === a ? d.parseQuery(this._parts.query) : void 0 !== a && "string" !== typeof a ? (this._parts.query = d.buildQuery(a, this._parts.duplicateQueryParameters), this.build(!b), this) : s.call(this, a, b) }; c.addQuery = function (a, b, e) {
        var c = d.parseQuery(this._parts.query);
        d.addQuery(c, a, void 0 === b ? null : b); this._parts.query = d.buildQuery(c, this._parts.duplicateQueryParameters); "string" !== typeof a && (e = b); this.build(!e); return this
    }; c.removeQuery = function (a, b, e) { var c = d.parseQuery(this._parts.query); d.removeQuery(c, a, b); this._parts.query = d.buildQuery(c, this._parts.duplicateQueryParameters); "string" !== typeof a && (e = b); this.build(!e); return this }; c.addSearch = c.addQuery; c.removeSearch = c.removeQuery; c.normalize = function () {
        return this._parts.urn ? this.normalizeProtocol(!1).normalizeQuery(!1).normalizeFragment(!1).build() :
        this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build()
    }; c.normalizeProtocol = function (a) { "string" === typeof this._parts.protocol && (this._parts.protocol = this._parts.protocol.toLowerCase(), this.build(!a)); return this }; c.normalizeHostname = function (a) {
        this._parts.hostname && (this.is("IDN") && f ? this._parts.hostname = f.toASCII(this._parts.hostname) : this.is("IPv6") && g && (this._parts.hostname = g.best(this._parts.hostname)), this._parts.hostname =
        this._parts.hostname.toLowerCase(), this.build(!a)); return this
    }; c.normalizePort = function (a) { "string" === typeof this._parts.protocol && this._parts.port === d.defaultPorts[this._parts.protocol] && (this._parts.port = null, this.build(!a)); return this }; c.normalizePath = function (a) {
        if (this._parts.urn || !this._parts.path || "/" === this._parts.path) return this; var b, e, c = this._parts.path, h, f; "/" !== c[0] && ("." === c[0] && (e = c.substring(0, c.indexOf("/"))), b = !0, c = "/" + c); for (c = c.replace(/(\/(\.\/)+)|\/{2,}/g, "/") ; ;) {
            h = c.indexOf("/../");
            if (-1 === h) break; else if (0 === h) { c = c.substring(3); break } f = c.substring(0, h).lastIndexOf("/"); -1 === f && (f = h); c = c.substring(0, f) + c.substring(h + 3)
        } b && this.is("relative") && (c = e ? e + c : c.substring(1)); c = d.recodePath(c); this._parts.path = c; this.build(!a); return this
    }; c.normalizePathname = c.normalizePath; c.normalizeQuery = function (a) { "string" === typeof this._parts.query && (this._parts.query.length ? this.query(d.parseQuery(this._parts.query)) : this._parts.query = null, this.build(!a)); return this }; c.normalizeFragment = function (a) {
        this._parts.fragment ||
        (this._parts.fragment = null, this.build(!a)); return this
    }; c.normalizeSearch = c.normalizeQuery; c.normalizeHash = c.normalizeFragment; c.iso8859 = function () { var a = d.encode, b = d.decode; d.encode = escape; d.decode = decodeURIComponent; this.normalize(); d.encode = a; d.decode = b; return this }; c.unicode = function () { var a = d.encode, b = d.decode; d.encode = h; d.decode = unescape; this.normalize(); d.encode = a; d.decode = b; return this }; c.readable = function () {
        var a = this.clone(); a.username("").password("").normalize(); var b = ""; a._parts.protocol &&
        (b += a._parts.protocol + "://"); a._parts.hostname && (a.is("punycode") && f ? (b += f.toUnicode(a._parts.hostname), a._parts.port && (b += ":" + a._parts.port)) : b += a.host()); a._parts.hostname && (a._parts.path && "/" !== a._parts.path[0]) && (b += "/"); b += a.path(!0); if (a._parts.query) { for (var c = "", h = 0, g = a._parts.query.split("&"), q = g.length; h < q; h++) { var k = (g[h] || "").split("="), c = c + ("&" + d.decodeQuery(k[0]).replace(/&/g, "%26")); void 0 !== k[1] && (c += "=" + d.decodeQuery(k[1]).replace(/&/g, "%26")) } b += "?" + c.substring(1) } return b += a.hash()
    };
    c.absoluteTo = function (a) {
        var b = this.clone(), c = ["protocol", "username", "password", "hostname", "port"], h, f; if (this._parts.urn) throw Error("URNs do not have any generally defined hierachical components"); if (this._parts.hostname) return b; a instanceof d || (a = new d(a)); h = 0; for (f; f = c[h]; h++) b._parts[f] = a._parts[f]; c = ["query", "path"]; h = 0; for (f; f = c[h]; h++) !b._parts[f] && a._parts[f] && (b._parts[f] = a._parts[f]); "/" !== b.path()[0] && (a = a.directory(), b._parts.path = (a ? a + "/" : "") + b._parts.path, b.normalizePath()); b.build();
        return b
    }; c.relativeTo = function (a) {
        var b = this.clone(), c = ["protocol", "username", "password", "hostname", "port"], h; if (this._parts.urn) throw Error("URNs do not have any generally defined hierachical components"); a instanceof d || (a = new d(a)); if ("/" !== this.path()[0] || "/" !== a.path()[0]) throw Error("Cannot calculate common path from non-relative URLs"); h = d.commonPath(b.path(), a.path()); if (!h || "/" === h) return b; for (var f = 0, g; g = c[f]; f++) b._parts[g] = null; a = a.directory(); c = this.directory(); if (a === c) return b._parts.path =
        "./" + b.filename(), b.build(); a.substring(h.length); c = c.substring(h.length); if (a + "/" === h) return c && (c += "/"), b._parts.path = "./" + c + b.filename(), b.build(); c = "../"; h = RegExp("^" + m(h)); for (a = a.replace(h, "/").match(/\//g).length - 1; a--;) c += "../"; b._parts.path = b._parts.path.replace(h, c); return b.build()
    }; c.equals = function (a) {
        var b = this.clone(), c = new d(a), h = {}, f = {}; a = {}; var g; b.normalize(); c.normalize(); if (b.toString() === c.toString()) return !0; h = b.query(); f = c.query(); b.query(""); c.query(""); if (b.toString() !==
        c.toString() || h.length !== f.length) return !1; h = d.parseQuery(h); f = d.parseQuery(f); for (g in h) if (q.call(h, g)) { if (u(h[g])) { if (!u(f[g]) || h[g].length !== f[g].length) return !1; h[g].sort(); f[g].sort(); b = 0; for (c = h[g].length; b < c; b++) if (h[g][b] !== f[g][b]) return !1 } else if (h[g] !== f[g]) return !1; a[g] = !0 } for (g in f) if (q.call(f, g) && !a[g]) return !1; return !0
    }; c.duplicateQueryParameters = function (a) { this._parts.duplicateQueryParameters = !!a; return this }; return d
});
(function (f, g) { "object" === typeof exports ? module.exports = g(require("./URI")) : "function" === typeof define && define.amd ? define(["./URI"], g) : f.URITemplate = g(f.URI) })(this, function (f) {
    function g(d) { if (g._cache[d]) return g._cache[d]; if (!(this instanceof g)) return new g(d); this.expression = d; g._cache[d] = this; return this } function j(d) { this.data = d; this.cache = {} } var d = Object.prototype.hasOwnProperty, m = g.prototype, u = {
        "": { prefix: "", separator: ",", named: !1, empty_name_separator: !1, encode: "encode" }, "+": {
            prefix: "", separator: ",",
            named: !1, empty_name_separator: !1, encode: "encodeReserved"
        }, "#": { prefix: "#", separator: ",", named: !1, empty_name_separator: !1, encode: "encodeReserved" }, ".": { prefix: ".", separator: ".", named: !1, empty_name_separator: !1, encode: "encode" }, "/": { prefix: "/", separator: "/", named: !1, empty_name_separator: !1, encode: "encode" }, ";": { prefix: ";", separator: ";", named: !0, empty_name_separator: !1, encode: "encode" }, "?": { prefix: "?", separator: "&", named: !0, empty_name_separator: !0, encode: "encode" }, "&": {
            prefix: "&", separator: "&", named: !0,
            empty_name_separator: !0, encode: "encode"
        }
    }; g._cache = {}; g.EXPRESSION_PATTERN = /\{([^a-zA-Z0-9%_]?)([^\}]+)(\}|$)/g; g.VARIABLE_PATTERN = /^([^*:]+)((\*)|:(\d+))?$/; g.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_]/; g.expand = function (d, c) { var f = u[d.operator], n = f.named ? "Named" : "Unnamed", k = d.variables, j = [], p, l, m; for (m = 0; l = k[m]; m++) p = c.get(l.name), p.val.length ? j.push(g["expand" + n](p, f, l.explode, l.explode && f.separator || ",", l.maxlength, l.name)) : p.type && j.push(""); return j.length ? f.prefix + j.join(f.separator) : "" }; g.expandNamed =
    function (d, c, g, n, k, j) { var p = "", l = c.encode; c = c.empty_name_separator; var m = !d[l].length, s = 2 === d.type ? "" : f[l](j), a, b, e; b = 0; for (e = d.val.length; b < e; b++) k ? (a = f[l](d.val[b][1].substring(0, k)), 2 === d.type && (s = f[l](d.val[b][0].substring(0, k)))) : m ? (a = f[l](d.val[b][1]), 2 === d.type ? (s = f[l](d.val[b][0]), d[l].push([s, a])) : d[l].push([void 0, a])) : (a = d[l][b][1], 2 === d.type && (s = d[l][b][0])), p && (p += n), g ? p += s + (c || a ? "=" : "") + a : (b || (p += f[l](j) + (c || a ? "=" : "")), 2 === d.type && (p += s + ","), p += a); return p }; g.expandUnnamed = function (d,
    c, g, j, k) { var r = "", p = c.encode; c = c.empty_name_separator; var l = !d[p].length, m, s, a, b; a = 0; for (b = d.val.length; a < b; a++) k ? s = f[p](d.val[a][1].substring(0, k)) : l ? (s = f[p](d.val[a][1]), d[p].push([2 === d.type ? f[p](d.val[a][0]) : void 0, s])) : s = d[p][a][1], r && (r += j), 2 === d.type && (m = k ? f[p](d.val[a][0].substring(0, k)) : d[p][a][0], r += m, r = g ? r + (c || s ? "=" : "") : r + ","), r += s; return r }; m.expand = function (d) {
        var c = ""; (!this.parts || !this.parts.length) && this.parse(); d instanceof j || (d = new j(d)); for (var f = 0, n = this.parts.length; f < n; f++) c +=
        "string" === typeof this.parts[f] ? this.parts[f] : g.expand(this.parts[f], d); return c
    }; m.parse = function () {
        var d = this.expression, c = g.EXPRESSION_PATTERN, f = g.VARIABLE_PATTERN, j = g.VARIABLE_NAME_PATTERN, k = [], m = 0, p, l, v; for (c.lastIndex = 0; ;) {
            l = c.exec(d); if (null === l) { k.push(d.substring(m)); break } else k.push(d.substring(m, l.index)), m = l.index + l[0].length; if (u[l[1]]) { if (!l[3]) throw Error('Unclosed Expression "' + l[0] + '"'); } else throw Error('Unknown Operator "' + l[1] + '" in "' + l[0] + '"'); p = l[2].split(","); for (var s = 0,
            a = p.length; s < a; s++) { v = p[s].match(f); if (null === v) throw Error('Invalid Variable "' + p[s] + '" in "' + l[0] + '"'); if (v[1].match(j)) throw Error('Invalid Variable Name "' + v[1] + '" in "' + l[0] + '"'); p[s] = { name: v[1], explode: !!v[3], maxlength: v[4] && parseInt(v[4], 10) } } if (!p.length) throw Error('Expression Missing Variable(s) "' + l[0] + '"'); k.push({ expression: l[0], operator: l[1], variables: p })
        } k.length || k.push(d); this.parts = k; return this
    }; j.prototype.get = function (f) {
        var c = this.data, g = { type: 0, val: [], encode: [], encodeReserved: [] },
        j; if (void 0 !== this.cache[f]) return this.cache[f]; this.cache[f] = g; c = "[object Function]" === String(Object.prototype.toString.call(c)) ? c(f) : "[object Function]" === String(Object.prototype.toString.call(c[f])) ? c[f](f) : c[f]; if (!(void 0 === c || null === c)) if ("[object Array]" === String(Object.prototype.toString.call(c))) { j = 0; for (f = c.length; j < f; j++) void 0 !== c[j] && null !== c[j] && g.val.push([void 0, String(c[j])]); g.val.length && (g.type = 3) } else if ("[object Object]" === String(Object.prototype.toString.call(c))) {
            for (j in c) d.call(c,
            j) && (void 0 !== c[j] && null !== c[j]) && g.val.push([j, String(c[j])]); g.val.length && (g.type = 2)
        } else g.type = 1, g.val.push([void 0, String(c)]); return g
    }; f.expand = function (d, c) { var j = (new g(d)).expand(c); return new f(j) }; return g
});
